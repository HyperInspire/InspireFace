// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MNNPLUGIN_MNNTRTPLUGIN_H_
#define FLATBUFFERS_GENERATED_MNNPLUGIN_MNNTRTPLUGIN_H_

#include "flatbuffers/flatbuffers.h"

namespace MNNTRTPlugin {

struct View;
struct ViewT;

struct Region;
struct RegionT;

struct InterpInfo;
struct InterpInfoT;

struct GatherInfo;
struct GatherInfoT;

struct OneHotInfo;
struct OneHotInfoT;

struct DetectionPostProcessInfo;
struct DetectionPostProcessInfoT;

struct ScatterNdInfo;
struct ScatterNdInfoT;

struct BroadCastInfo;
struct BroadCastInfoT;

struct RasterInfo;
struct RasterInfoT;

struct Shape;
struct ShapeT;

struct Plugin;
struct PluginT;

inline const flatbuffers::TypeTable *ViewTypeTable();

inline const flatbuffers::TypeTable *RegionTypeTable();

inline const flatbuffers::TypeTable *InterpInfoTypeTable();

inline const flatbuffers::TypeTable *GatherInfoTypeTable();

inline const flatbuffers::TypeTable *OneHotInfoTypeTable();

inline const flatbuffers::TypeTable *DetectionPostProcessInfoTypeTable();

inline const flatbuffers::TypeTable *ScatterNdInfoTypeTable();

inline const flatbuffers::TypeTable *BroadCastInfoTypeTable();

inline const flatbuffers::TypeTable *RasterInfoTypeTable();

inline const flatbuffers::TypeTable *ShapeTypeTable();

inline const flatbuffers::TypeTable *PluginTypeTable();

enum ExtraType {
  ExtraType_Normal = 0,
  ExtraType_Fill = 1,
  ExtraType_MIN = ExtraType_Normal,
  ExtraType_MAX = ExtraType_Fill
};

inline const ExtraType (&EnumValuesExtraType())[2] {
  static const ExtraType values[] = {
    ExtraType_Normal,
    ExtraType_Fill
  };
  return values;
}

inline const char * const *EnumNamesExtraType() {
  static const char * const names[] = {
    "Normal",
    "Fill",
    nullptr
  };
  return names;
}

inline const char *EnumNameExtraType(ExtraType e) {
  if (e < ExtraType_Normal || e > ExtraType_Fill) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesExtraType()[index];
}

enum Parameter {
  Parameter_NONE = 0,
  Parameter_RasterInfo = 1,
  Parameter_BroadCastInfo = 2,
  Parameter_ScatterNdInfo = 3,
  Parameter_InterpInfo = 4,
  Parameter_GatherInfo = 5,
  Parameter_DetectionPostProcessInfo = 6,
  Parameter_OneHotInfo = 7,
  Parameter_MIN = Parameter_NONE,
  Parameter_MAX = Parameter_OneHotInfo
};

inline const Parameter (&EnumValuesParameter())[8] {
  static const Parameter values[] = {
    Parameter_NONE,
    Parameter_RasterInfo,
    Parameter_BroadCastInfo,
    Parameter_ScatterNdInfo,
    Parameter_InterpInfo,
    Parameter_GatherInfo,
    Parameter_DetectionPostProcessInfo,
    Parameter_OneHotInfo
  };
  return values;
}

inline const char * const *EnumNamesParameter() {
  static const char * const names[] = {
    "NONE",
    "RasterInfo",
    "BroadCastInfo",
    "ScatterNdInfo",
    "InterpInfo",
    "GatherInfo",
    "DetectionPostProcessInfo",
    "OneHotInfo",
    nullptr
  };
  return names;
}

inline const char *EnumNameParameter(Parameter e) {
  if (e < Parameter_NONE || e > Parameter_OneHotInfo) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesParameter()[index];
}

template<typename T> struct ParameterTraits {
  static const Parameter enum_value = Parameter_NONE;
};

template<> struct ParameterTraits<RasterInfo> {
  static const Parameter enum_value = Parameter_RasterInfo;
};

template<> struct ParameterTraits<BroadCastInfo> {
  static const Parameter enum_value = Parameter_BroadCastInfo;
};

template<> struct ParameterTraits<ScatterNdInfo> {
  static const Parameter enum_value = Parameter_ScatterNdInfo;
};

template<> struct ParameterTraits<InterpInfo> {
  static const Parameter enum_value = Parameter_InterpInfo;
};

template<> struct ParameterTraits<GatherInfo> {
  static const Parameter enum_value = Parameter_GatherInfo;
};

template<> struct ParameterTraits<DetectionPostProcessInfo> {
  static const Parameter enum_value = Parameter_DetectionPostProcessInfo;
};

template<> struct ParameterTraits<OneHotInfo> {
  static const Parameter enum_value = Parameter_OneHotInfo;
};

struct ParameterUnion {
  Parameter type;
  void *value;

  ParameterUnion() : type(Parameter_NONE), value(nullptr) {}
  ParameterUnion(ParameterUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Parameter_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ParameterUnion(const ParameterUnion &) FLATBUFFERS_NOEXCEPT;
  ParameterUnion &operator=(const ParameterUnion &u) FLATBUFFERS_NOEXCEPT
    { ParameterUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ParameterUnion &operator=(ParameterUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ParameterUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ParameterTraits<typename T::TableType>::enum_value;
    if (type != Parameter_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Parameter type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  RasterInfoT *AsRasterInfo() {
    return type == Parameter_RasterInfo ?
      reinterpret_cast<RasterInfoT *>(value) : nullptr;
  }
  const RasterInfoT *AsRasterInfo() const {
    return type == Parameter_RasterInfo ?
      reinterpret_cast<const RasterInfoT *>(value) : nullptr;
  }
  BroadCastInfoT *AsBroadCastInfo() {
    return type == Parameter_BroadCastInfo ?
      reinterpret_cast<BroadCastInfoT *>(value) : nullptr;
  }
  const BroadCastInfoT *AsBroadCastInfo() const {
    return type == Parameter_BroadCastInfo ?
      reinterpret_cast<const BroadCastInfoT *>(value) : nullptr;
  }
  ScatterNdInfoT *AsScatterNdInfo() {
    return type == Parameter_ScatterNdInfo ?
      reinterpret_cast<ScatterNdInfoT *>(value) : nullptr;
  }
  const ScatterNdInfoT *AsScatterNdInfo() const {
    return type == Parameter_ScatterNdInfo ?
      reinterpret_cast<const ScatterNdInfoT *>(value) : nullptr;
  }
  InterpInfoT *AsInterpInfo() {
    return type == Parameter_InterpInfo ?
      reinterpret_cast<InterpInfoT *>(value) : nullptr;
  }
  const InterpInfoT *AsInterpInfo() const {
    return type == Parameter_InterpInfo ?
      reinterpret_cast<const InterpInfoT *>(value) : nullptr;
  }
  GatherInfoT *AsGatherInfo() {
    return type == Parameter_GatherInfo ?
      reinterpret_cast<GatherInfoT *>(value) : nullptr;
  }
  const GatherInfoT *AsGatherInfo() const {
    return type == Parameter_GatherInfo ?
      reinterpret_cast<const GatherInfoT *>(value) : nullptr;
  }
  DetectionPostProcessInfoT *AsDetectionPostProcessInfo() {
    return type == Parameter_DetectionPostProcessInfo ?
      reinterpret_cast<DetectionPostProcessInfoT *>(value) : nullptr;
  }
  const DetectionPostProcessInfoT *AsDetectionPostProcessInfo() const {
    return type == Parameter_DetectionPostProcessInfo ?
      reinterpret_cast<const DetectionPostProcessInfoT *>(value) : nullptr;
  }
  OneHotInfoT *AsOneHotInfo() {
    return type == Parameter_OneHotInfo ?
      reinterpret_cast<OneHotInfoT *>(value) : nullptr;
  }
  const OneHotInfoT *AsOneHotInfo() const {
    return type == Parameter_OneHotInfo ?
      reinterpret_cast<const OneHotInfoT *>(value) : nullptr;
  }
};

bool VerifyParameter(flatbuffers::Verifier &verifier, const void *obj, Parameter type);
bool VerifyParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ViewT : public flatbuffers::NativeTable {
  typedef View TableType;
  int32_t offset;
  std::vector<int32_t> stride;
  ViewT()
      : offset(0) {
  }
};

struct View FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ViewTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_STRIDE = 6
  };
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           verifier.EndTable();
  }
  ViewT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ViewT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<View> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(View::VT_OFFSET, offset, 0);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(View::VT_STRIDE, stride);
  }
  explicit ViewBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ViewBuilder &operator=(const ViewBuilder &);
  flatbuffers::Offset<View> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<View>(end);
    return o;
  }
};

inline flatbuffers::Offset<View> CreateView(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride = 0) {
  ViewBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_offset(offset);
  return builder_.Finish();
}

inline flatbuffers::Offset<View> CreateViewDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t offset = 0,
    const std::vector<int32_t> *stride = nullptr) {
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  return MNNTRTPlugin::CreateView(
      _fbb,
      offset,
      stride__);
}

flatbuffers::Offset<View> CreateView(flatbuffers::FlatBufferBuilder &_fbb, const ViewT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RegionT : public flatbuffers::NativeTable {
  typedef Region TableType;
  std::unique_ptr<ViewT> src;
  std::unique_ptr<ViewT> dst;
  std::vector<int32_t> size;
  int32_t index;
  RegionT()
      : index(0) {
  }
};

struct Region FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RegionT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RegionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC = 4,
    VT_DST = 6,
    VT_SIZE = 8,
    VT_INDEX = 10
  };
  const View *src() const {
    return GetPointer<const View *>(VT_SRC);
  }
  const View *dst() const {
    return GetPointer<const View *>(VT_DST);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SRC) &&
           verifier.VerifyTable(src()) &&
           VerifyOffset(verifier, VT_DST) &&
           verifier.VerifyTable(dst()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
  RegionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RegionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Region> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RegionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(flatbuffers::Offset<View> src) {
    fbb_.AddOffset(Region::VT_SRC, src);
  }
  void add_dst(flatbuffers::Offset<View> dst) {
    fbb_.AddOffset(Region::VT_DST, dst);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(Region::VT_SIZE, size);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(Region::VT_INDEX, index, 0);
  }
  explicit RegionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RegionBuilder &operator=(const RegionBuilder &);
  flatbuffers::Offset<Region> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Region>(end);
    return o;
  }
};

inline flatbuffers::Offset<Region> CreateRegion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<View> src = 0,
    flatbuffers::Offset<View> dst = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0,
    int32_t index = 0) {
  RegionBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_size(size);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

inline flatbuffers::Offset<Region> CreateRegionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<View> src = 0,
    flatbuffers::Offset<View> dst = 0,
    const std::vector<int32_t> *size = nullptr,
    int32_t index = 0) {
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  return MNNTRTPlugin::CreateRegion(
      _fbb,
      src,
      dst,
      size__,
      index);
}

flatbuffers::Offset<Region> CreateRegion(flatbuffers::FlatBufferBuilder &_fbb, const RegionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InterpInfoT : public flatbuffers::NativeTable {
  typedef InterpInfo TableType;
  int32_t inputChannel;
  float heightScale;
  float widthScale;
  int32_t channelBlocks;
  int32_t outputWidth;
  int32_t outputH_N;
  int32_t inputHeight;
  int32_t inputWidth;
  int32_t outputHeight;
  InterpInfoT()
      : inputChannel(0),
        heightScale(0.0f),
        widthScale(0.0f),
        channelBlocks(0),
        outputWidth(0),
        outputH_N(0),
        inputHeight(0),
        inputWidth(0),
        outputHeight(0) {
  }
};

struct InterpInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterpInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return InterpInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTCHANNEL = 4,
    VT_HEIGHTSCALE = 6,
    VT_WIDTHSCALE = 8,
    VT_CHANNELBLOCKS = 10,
    VT_OUTPUTWIDTH = 12,
    VT_OUTPUTH_N = 14,
    VT_INPUTHEIGHT = 16,
    VT_INPUTWIDTH = 18,
    VT_OUTPUTHEIGHT = 20
  };
  int32_t inputChannel() const {
    return GetField<int32_t>(VT_INPUTCHANNEL, 0);
  }
  float heightScale() const {
    return GetField<float>(VT_HEIGHTSCALE, 0.0f);
  }
  float widthScale() const {
    return GetField<float>(VT_WIDTHSCALE, 0.0f);
  }
  int32_t channelBlocks() const {
    return GetField<int32_t>(VT_CHANNELBLOCKS, 0);
  }
  int32_t outputWidth() const {
    return GetField<int32_t>(VT_OUTPUTWIDTH, 0);
  }
  int32_t outputH_N() const {
    return GetField<int32_t>(VT_OUTPUTH_N, 0);
  }
  int32_t inputHeight() const {
    return GetField<int32_t>(VT_INPUTHEIGHT, 0);
  }
  int32_t inputWidth() const {
    return GetField<int32_t>(VT_INPUTWIDTH, 0);
  }
  int32_t outputHeight() const {
    return GetField<int32_t>(VT_OUTPUTHEIGHT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INPUTCHANNEL) &&
           VerifyField<float>(verifier, VT_HEIGHTSCALE) &&
           VerifyField<float>(verifier, VT_WIDTHSCALE) &&
           VerifyField<int32_t>(verifier, VT_CHANNELBLOCKS) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTWIDTH) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTH_N) &&
           VerifyField<int32_t>(verifier, VT_INPUTHEIGHT) &&
           VerifyField<int32_t>(verifier, VT_INPUTWIDTH) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTHEIGHT) &&
           verifier.EndTable();
  }
  InterpInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InterpInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InterpInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InterpInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputChannel(int32_t inputChannel) {
    fbb_.AddElement<int32_t>(InterpInfo::VT_INPUTCHANNEL, inputChannel, 0);
  }
  void add_heightScale(float heightScale) {
    fbb_.AddElement<float>(InterpInfo::VT_HEIGHTSCALE, heightScale, 0.0f);
  }
  void add_widthScale(float widthScale) {
    fbb_.AddElement<float>(InterpInfo::VT_WIDTHSCALE, widthScale, 0.0f);
  }
  void add_channelBlocks(int32_t channelBlocks) {
    fbb_.AddElement<int32_t>(InterpInfo::VT_CHANNELBLOCKS, channelBlocks, 0);
  }
  void add_outputWidth(int32_t outputWidth) {
    fbb_.AddElement<int32_t>(InterpInfo::VT_OUTPUTWIDTH, outputWidth, 0);
  }
  void add_outputH_N(int32_t outputH_N) {
    fbb_.AddElement<int32_t>(InterpInfo::VT_OUTPUTH_N, outputH_N, 0);
  }
  void add_inputHeight(int32_t inputHeight) {
    fbb_.AddElement<int32_t>(InterpInfo::VT_INPUTHEIGHT, inputHeight, 0);
  }
  void add_inputWidth(int32_t inputWidth) {
    fbb_.AddElement<int32_t>(InterpInfo::VT_INPUTWIDTH, inputWidth, 0);
  }
  void add_outputHeight(int32_t outputHeight) {
    fbb_.AddElement<int32_t>(InterpInfo::VT_OUTPUTHEIGHT, outputHeight, 0);
  }
  explicit InterpInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InterpInfoBuilder &operator=(const InterpInfoBuilder &);
  flatbuffers::Offset<InterpInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InterpInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<InterpInfo> CreateInterpInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t inputChannel = 0,
    float heightScale = 0.0f,
    float widthScale = 0.0f,
    int32_t channelBlocks = 0,
    int32_t outputWidth = 0,
    int32_t outputH_N = 0,
    int32_t inputHeight = 0,
    int32_t inputWidth = 0,
    int32_t outputHeight = 0) {
  InterpInfoBuilder builder_(_fbb);
  builder_.add_outputHeight(outputHeight);
  builder_.add_inputWidth(inputWidth);
  builder_.add_inputHeight(inputHeight);
  builder_.add_outputH_N(outputH_N);
  builder_.add_outputWidth(outputWidth);
  builder_.add_channelBlocks(channelBlocks);
  builder_.add_widthScale(widthScale);
  builder_.add_heightScale(heightScale);
  builder_.add_inputChannel(inputChannel);
  return builder_.Finish();
}

flatbuffers::Offset<InterpInfo> CreateInterpInfo(flatbuffers::FlatBufferBuilder &_fbb, const InterpInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GatherInfoT : public flatbuffers::NativeTable {
  typedef GatherInfo TableType;
  int32_t limit;
  int32_t insideStride;
  int32_t N;
  int32_t outputOutsideStride;
  int32_t inputOutsideStride;
  int32_t outside;
  bool input3;
  GatherInfoT()
      : limit(0),
        insideStride(0),
        N(0),
        outputOutsideStride(0),
        inputOutsideStride(0),
        outside(0),
        input3(false) {
  }
};

struct GatherInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GatherInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIMIT = 4,
    VT_INSIDESTRIDE = 6,
    VT_N = 8,
    VT_OUTPUTOUTSIDESTRIDE = 10,
    VT_INPUTOUTSIDESTRIDE = 12,
    VT_OUTSIDE = 14,
    VT_INPUT3 = 16
  };
  int32_t limit() const {
    return GetField<int32_t>(VT_LIMIT, 0);
  }
  int32_t insideStride() const {
    return GetField<int32_t>(VT_INSIDESTRIDE, 0);
  }
  int32_t N() const {
    return GetField<int32_t>(VT_N, 0);
  }
  int32_t outputOutsideStride() const {
    return GetField<int32_t>(VT_OUTPUTOUTSIDESTRIDE, 0);
  }
  int32_t inputOutsideStride() const {
    return GetField<int32_t>(VT_INPUTOUTSIDESTRIDE, 0);
  }
  int32_t outside() const {
    return GetField<int32_t>(VT_OUTSIDE, 0);
  }
  bool input3() const {
    return GetField<uint8_t>(VT_INPUT3, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LIMIT) &&
           VerifyField<int32_t>(verifier, VT_INSIDESTRIDE) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTOUTSIDESTRIDE) &&
           VerifyField<int32_t>(verifier, VT_INPUTOUTSIDESTRIDE) &&
           VerifyField<int32_t>(verifier, VT_OUTSIDE) &&
           VerifyField<uint8_t>(verifier, VT_INPUT3) &&
           verifier.EndTable();
  }
  GatherInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GatherInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GatherInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GatherInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_limit(int32_t limit) {
    fbb_.AddElement<int32_t>(GatherInfo::VT_LIMIT, limit, 0);
  }
  void add_insideStride(int32_t insideStride) {
    fbb_.AddElement<int32_t>(GatherInfo::VT_INSIDESTRIDE, insideStride, 0);
  }
  void add_N(int32_t N) {
    fbb_.AddElement<int32_t>(GatherInfo::VT_N, N, 0);
  }
  void add_outputOutsideStride(int32_t outputOutsideStride) {
    fbb_.AddElement<int32_t>(GatherInfo::VT_OUTPUTOUTSIDESTRIDE, outputOutsideStride, 0);
  }
  void add_inputOutsideStride(int32_t inputOutsideStride) {
    fbb_.AddElement<int32_t>(GatherInfo::VT_INPUTOUTSIDESTRIDE, inputOutsideStride, 0);
  }
  void add_outside(int32_t outside) {
    fbb_.AddElement<int32_t>(GatherInfo::VT_OUTSIDE, outside, 0);
  }
  void add_input3(bool input3) {
    fbb_.AddElement<uint8_t>(GatherInfo::VT_INPUT3, static_cast<uint8_t>(input3), 0);
  }
  explicit GatherInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherInfoBuilder &operator=(const GatherInfoBuilder &);
  flatbuffers::Offset<GatherInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherInfo> CreateGatherInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t limit = 0,
    int32_t insideStride = 0,
    int32_t N = 0,
    int32_t outputOutsideStride = 0,
    int32_t inputOutsideStride = 0,
    int32_t outside = 0,
    bool input3 = false) {
  GatherInfoBuilder builder_(_fbb);
  builder_.add_outside(outside);
  builder_.add_inputOutsideStride(inputOutsideStride);
  builder_.add_outputOutsideStride(outputOutsideStride);
  builder_.add_N(N);
  builder_.add_insideStride(insideStride);
  builder_.add_limit(limit);
  builder_.add_input3(input3);
  return builder_.Finish();
}

flatbuffers::Offset<GatherInfo> CreateGatherInfo(flatbuffers::FlatBufferBuilder &_fbb, const GatherInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OneHotInfoT : public flatbuffers::NativeTable {
  typedef OneHotInfo TableType;
  int32_t outerSize;
  int32_t innerSize;
  OneHotInfoT()
      : outerSize(0),
        innerSize(0) {
  }
};

struct OneHotInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneHotInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OneHotInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTERSIZE = 4,
    VT_INNERSIZE = 6
  };
  int32_t outerSize() const {
    return GetField<int32_t>(VT_OUTERSIZE, 0);
  }
  int32_t innerSize() const {
    return GetField<int32_t>(VT_INNERSIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTERSIZE) &&
           VerifyField<int32_t>(verifier, VT_INNERSIZE) &&
           verifier.EndTable();
  }
  OneHotInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OneHotInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<OneHotInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OneHotInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outerSize(int32_t outerSize) {
    fbb_.AddElement<int32_t>(OneHotInfo::VT_OUTERSIZE, outerSize, 0);
  }
  void add_innerSize(int32_t innerSize) {
    fbb_.AddElement<int32_t>(OneHotInfo::VT_INNERSIZE, innerSize, 0);
  }
  explicit OneHotInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotInfoBuilder &operator=(const OneHotInfoBuilder &);
  flatbuffers::Offset<OneHotInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotInfo> CreateOneHotInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outerSize = 0,
    int32_t innerSize = 0) {
  OneHotInfoBuilder builder_(_fbb);
  builder_.add_innerSize(innerSize);
  builder_.add_outerSize(outerSize);
  return builder_.Finish();
}

flatbuffers::Offset<OneHotInfo> CreateOneHotInfo(flatbuffers::FlatBufferBuilder &_fbb, const OneHotInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DetectionPostProcessInfoT : public flatbuffers::NativeTable {
  typedef DetectionPostProcessInfo TableType;
  int32_t numAnchors0;
  std::vector<float> scaleValues;
  int32_t numBoxes;
  int32_t boxCoordNum;
  int32_t anchorsCoordNum;
  int32_t numAnchors1;
  int32_t numClassWithBackground;
  int32_t numClasses;
  int32_t maxClassesPerAnchor;
  int32_t maxDetections;
  float iouThreshold;
  float nmsScoreThreshold;
  DetectionPostProcessInfoT()
      : numAnchors0(0),
        numBoxes(0),
        boxCoordNum(0),
        anchorsCoordNum(0),
        numAnchors1(0),
        numClassWithBackground(0),
        numClasses(0),
        maxClassesPerAnchor(0),
        maxDetections(0),
        iouThreshold(0.0f),
        nmsScoreThreshold(0.0f) {
  }
};

struct DetectionPostProcessInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionPostProcessInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DetectionPostProcessInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMANCHORS0 = 4,
    VT_SCALEVALUES = 6,
    VT_NUMBOXES = 8,
    VT_BOXCOORDNUM = 10,
    VT_ANCHORSCOORDNUM = 12,
    VT_NUMANCHORS1 = 14,
    VT_NUMCLASSWITHBACKGROUND = 16,
    VT_NUMCLASSES = 18,
    VT_MAXCLASSESPERANCHOR = 20,
    VT_MAXDETECTIONS = 22,
    VT_IOUTHRESHOLD = 24,
    VT_NMSSCORETHRESHOLD = 26
  };
  int32_t numAnchors0() const {
    return GetField<int32_t>(VT_NUMANCHORS0, 0);
  }
  const flatbuffers::Vector<float> *scaleValues() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALEVALUES);
  }
  int32_t numBoxes() const {
    return GetField<int32_t>(VT_NUMBOXES, 0);
  }
  int32_t boxCoordNum() const {
    return GetField<int32_t>(VT_BOXCOORDNUM, 0);
  }
  int32_t anchorsCoordNum() const {
    return GetField<int32_t>(VT_ANCHORSCOORDNUM, 0);
  }
  int32_t numAnchors1() const {
    return GetField<int32_t>(VT_NUMANCHORS1, 0);
  }
  int32_t numClassWithBackground() const {
    return GetField<int32_t>(VT_NUMCLASSWITHBACKGROUND, 0);
  }
  int32_t numClasses() const {
    return GetField<int32_t>(VT_NUMCLASSES, 0);
  }
  int32_t maxClassesPerAnchor() const {
    return GetField<int32_t>(VT_MAXCLASSESPERANCHOR, 0);
  }
  int32_t maxDetections() const {
    return GetField<int32_t>(VT_MAXDETECTIONS, 0);
  }
  float iouThreshold() const {
    return GetField<float>(VT_IOUTHRESHOLD, 0.0f);
  }
  float nmsScoreThreshold() const {
    return GetField<float>(VT_NMSSCORETHRESHOLD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMANCHORS0) &&
           VerifyOffset(verifier, VT_SCALEVALUES) &&
           verifier.VerifyVector(scaleValues()) &&
           VerifyField<int32_t>(verifier, VT_NUMBOXES) &&
           VerifyField<int32_t>(verifier, VT_BOXCOORDNUM) &&
           VerifyField<int32_t>(verifier, VT_ANCHORSCOORDNUM) &&
           VerifyField<int32_t>(verifier, VT_NUMANCHORS1) &&
           VerifyField<int32_t>(verifier, VT_NUMCLASSWITHBACKGROUND) &&
           VerifyField<int32_t>(verifier, VT_NUMCLASSES) &&
           VerifyField<int32_t>(verifier, VT_MAXCLASSESPERANCHOR) &&
           VerifyField<int32_t>(verifier, VT_MAXDETECTIONS) &&
           VerifyField<float>(verifier, VT_IOUTHRESHOLD) &&
           VerifyField<float>(verifier, VT_NMSSCORETHRESHOLD) &&
           verifier.EndTable();
  }
  DetectionPostProcessInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DetectionPostProcessInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DetectionPostProcessInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DetectionPostProcessInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numAnchors0(int32_t numAnchors0) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_NUMANCHORS0, numAnchors0, 0);
  }
  void add_scaleValues(flatbuffers::Offset<flatbuffers::Vector<float>> scaleValues) {
    fbb_.AddOffset(DetectionPostProcessInfo::VT_SCALEVALUES, scaleValues);
  }
  void add_numBoxes(int32_t numBoxes) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_NUMBOXES, numBoxes, 0);
  }
  void add_boxCoordNum(int32_t boxCoordNum) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_BOXCOORDNUM, boxCoordNum, 0);
  }
  void add_anchorsCoordNum(int32_t anchorsCoordNum) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_ANCHORSCOORDNUM, anchorsCoordNum, 0);
  }
  void add_numAnchors1(int32_t numAnchors1) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_NUMANCHORS1, numAnchors1, 0);
  }
  void add_numClassWithBackground(int32_t numClassWithBackground) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_NUMCLASSWITHBACKGROUND, numClassWithBackground, 0);
  }
  void add_numClasses(int32_t numClasses) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_NUMCLASSES, numClasses, 0);
  }
  void add_maxClassesPerAnchor(int32_t maxClassesPerAnchor) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_MAXCLASSESPERANCHOR, maxClassesPerAnchor, 0);
  }
  void add_maxDetections(int32_t maxDetections) {
    fbb_.AddElement<int32_t>(DetectionPostProcessInfo::VT_MAXDETECTIONS, maxDetections, 0);
  }
  void add_iouThreshold(float iouThreshold) {
    fbb_.AddElement<float>(DetectionPostProcessInfo::VT_IOUTHRESHOLD, iouThreshold, 0.0f);
  }
  void add_nmsScoreThreshold(float nmsScoreThreshold) {
    fbb_.AddElement<float>(DetectionPostProcessInfo::VT_NMSSCORETHRESHOLD, nmsScoreThreshold, 0.0f);
  }
  explicit DetectionPostProcessInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectionPostProcessInfoBuilder &operator=(const DetectionPostProcessInfoBuilder &);
  flatbuffers::Offset<DetectionPostProcessInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionPostProcessInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionPostProcessInfo> CreateDetectionPostProcessInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numAnchors0 = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scaleValues = 0,
    int32_t numBoxes = 0,
    int32_t boxCoordNum = 0,
    int32_t anchorsCoordNum = 0,
    int32_t numAnchors1 = 0,
    int32_t numClassWithBackground = 0,
    int32_t numClasses = 0,
    int32_t maxClassesPerAnchor = 0,
    int32_t maxDetections = 0,
    float iouThreshold = 0.0f,
    float nmsScoreThreshold = 0.0f) {
  DetectionPostProcessInfoBuilder builder_(_fbb);
  builder_.add_nmsScoreThreshold(nmsScoreThreshold);
  builder_.add_iouThreshold(iouThreshold);
  builder_.add_maxDetections(maxDetections);
  builder_.add_maxClassesPerAnchor(maxClassesPerAnchor);
  builder_.add_numClasses(numClasses);
  builder_.add_numClassWithBackground(numClassWithBackground);
  builder_.add_numAnchors1(numAnchors1);
  builder_.add_anchorsCoordNum(anchorsCoordNum);
  builder_.add_boxCoordNum(boxCoordNum);
  builder_.add_numBoxes(numBoxes);
  builder_.add_scaleValues(scaleValues);
  builder_.add_numAnchors0(numAnchors0);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectionPostProcessInfo> CreateDetectionPostProcessInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numAnchors0 = 0,
    const std::vector<float> *scaleValues = nullptr,
    int32_t numBoxes = 0,
    int32_t boxCoordNum = 0,
    int32_t anchorsCoordNum = 0,
    int32_t numAnchors1 = 0,
    int32_t numClassWithBackground = 0,
    int32_t numClasses = 0,
    int32_t maxClassesPerAnchor = 0,
    int32_t maxDetections = 0,
    float iouThreshold = 0.0f,
    float nmsScoreThreshold = 0.0f) {
  auto scaleValues__ = scaleValues ? _fbb.CreateVector<float>(*scaleValues) : 0;
  return MNNTRTPlugin::CreateDetectionPostProcessInfo(
      _fbb,
      numAnchors0,
      scaleValues__,
      numBoxes,
      boxCoordNum,
      anchorsCoordNum,
      numAnchors1,
      numClassWithBackground,
      numClasses,
      maxClassesPerAnchor,
      maxDetections,
      iouThreshold,
      nmsScoreThreshold);
}

flatbuffers::Offset<DetectionPostProcessInfo> CreateDetectionPostProcessInfo(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScatterNdInfoT : public flatbuffers::NativeTable {
  typedef ScatterNdInfo TableType;
  int32_t indicesLastDim;
  int32_t indexes;
  int32_t accNumber;
  int32_t outElementSize;
  std::vector<int32_t> dimsToCount;
  ScatterNdInfoT()
      : indicesLastDim(0),
        indexes(0),
        accNumber(0),
        outElementSize(0) {
  }
};

struct ScatterNdInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterNdInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ScatterNdInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICESLASTDIM = 4,
    VT_INDEXES = 6,
    VT_ACCNUMBER = 8,
    VT_OUTELEMENTSIZE = 10,
    VT_DIMSTOCOUNT = 12
  };
  int32_t indicesLastDim() const {
    return GetField<int32_t>(VT_INDICESLASTDIM, 0);
  }
  int32_t indexes() const {
    return GetField<int32_t>(VT_INDEXES, 0);
  }
  int32_t accNumber() const {
    return GetField<int32_t>(VT_ACCNUMBER, 0);
  }
  int32_t outElementSize() const {
    return GetField<int32_t>(VT_OUTELEMENTSIZE, 0);
  }
  const flatbuffers::Vector<int32_t> *dimsToCount() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMSTOCOUNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDICESLASTDIM) &&
           VerifyField<int32_t>(verifier, VT_INDEXES) &&
           VerifyField<int32_t>(verifier, VT_ACCNUMBER) &&
           VerifyField<int32_t>(verifier, VT_OUTELEMENTSIZE) &&
           VerifyOffset(verifier, VT_DIMSTOCOUNT) &&
           verifier.VerifyVector(dimsToCount()) &&
           verifier.EndTable();
  }
  ScatterNdInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScatterNdInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScatterNdInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScatterNdInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indicesLastDim(int32_t indicesLastDim) {
    fbb_.AddElement<int32_t>(ScatterNdInfo::VT_INDICESLASTDIM, indicesLastDim, 0);
  }
  void add_indexes(int32_t indexes) {
    fbb_.AddElement<int32_t>(ScatterNdInfo::VT_INDEXES, indexes, 0);
  }
  void add_accNumber(int32_t accNumber) {
    fbb_.AddElement<int32_t>(ScatterNdInfo::VT_ACCNUMBER, accNumber, 0);
  }
  void add_outElementSize(int32_t outElementSize) {
    fbb_.AddElement<int32_t>(ScatterNdInfo::VT_OUTELEMENTSIZE, outElementSize, 0);
  }
  void add_dimsToCount(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dimsToCount) {
    fbb_.AddOffset(ScatterNdInfo::VT_DIMSTOCOUNT, dimsToCount);
  }
  explicit ScatterNdInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterNdInfoBuilder &operator=(const ScatterNdInfoBuilder &);
  flatbuffers::Offset<ScatterNdInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdInfo> CreateScatterNdInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t indicesLastDim = 0,
    int32_t indexes = 0,
    int32_t accNumber = 0,
    int32_t outElementSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dimsToCount = 0) {
  ScatterNdInfoBuilder builder_(_fbb);
  builder_.add_dimsToCount(dimsToCount);
  builder_.add_outElementSize(outElementSize);
  builder_.add_accNumber(accNumber);
  builder_.add_indexes(indexes);
  builder_.add_indicesLastDim(indicesLastDim);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScatterNdInfo> CreateScatterNdInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t indicesLastDim = 0,
    int32_t indexes = 0,
    int32_t accNumber = 0,
    int32_t outElementSize = 0,
    const std::vector<int32_t> *dimsToCount = nullptr) {
  auto dimsToCount__ = dimsToCount ? _fbb.CreateVector<int32_t>(*dimsToCount) : 0;
  return MNNTRTPlugin::CreateScatterNdInfo(
      _fbb,
      indicesLastDim,
      indexes,
      accNumber,
      outElementSize,
      dimsToCount__);
}

flatbuffers::Offset<ScatterNdInfo> CreateScatterNdInfo(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BroadCastInfoT : public flatbuffers::NativeTable {
  typedef BroadCastInfo TableType;
  bool input0;
  bool input1;
  BroadCastInfoT()
      : input0(false),
        input1(false) {
  }
};

struct BroadCastInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadCastInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BroadCastInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT0 = 4,
    VT_INPUT1 = 6
  };
  bool input0() const {
    return GetField<uint8_t>(VT_INPUT0, 0) != 0;
  }
  bool input1() const {
    return GetField<uint8_t>(VT_INPUT1, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INPUT0) &&
           VerifyField<uint8_t>(verifier, VT_INPUT1) &&
           verifier.EndTable();
  }
  BroadCastInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BroadCastInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BroadCastInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadCastInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BroadCastInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input0(bool input0) {
    fbb_.AddElement<uint8_t>(BroadCastInfo::VT_INPUT0, static_cast<uint8_t>(input0), 0);
  }
  void add_input1(bool input1) {
    fbb_.AddElement<uint8_t>(BroadCastInfo::VT_INPUT1, static_cast<uint8_t>(input1), 0);
  }
  explicit BroadCastInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadCastInfoBuilder &operator=(const BroadCastInfoBuilder &);
  flatbuffers::Offset<BroadCastInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadCastInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadCastInfo> CreateBroadCastInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool input0 = false,
    bool input1 = false) {
  BroadCastInfoBuilder builder_(_fbb);
  builder_.add_input1(input1);
  builder_.add_input0(input0);
  return builder_.Finish();
}

flatbuffers::Offset<BroadCastInfo> CreateBroadCastInfo(flatbuffers::FlatBufferBuilder &_fbb, const BroadCastInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RasterInfoT : public flatbuffers::NativeTable {
  typedef RasterInfo TableType;
  std::vector<std::unique_ptr<RegionT>> regions;
  ExtraType extra;
  RasterInfoT()
      : extra(ExtraType_Normal) {
  }
};

struct RasterInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RasterInfoT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RasterInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGIONS = 4,
    VT_EXTRA = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Region>> *regions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Region>> *>(VT_REGIONS);
  }
  ExtraType extra() const {
    return static_cast<ExtraType>(GetField<int8_t>(VT_EXTRA, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REGIONS) &&
           verifier.VerifyVector(regions()) &&
           verifier.VerifyVectorOfTables(regions()) &&
           VerifyField<int8_t>(verifier, VT_EXTRA) &&
           verifier.EndTable();
  }
  RasterInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RasterInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RasterInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RasterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RasterInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_regions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Region>>> regions) {
    fbb_.AddOffset(RasterInfo::VT_REGIONS, regions);
  }
  void add_extra(ExtraType extra) {
    fbb_.AddElement<int8_t>(RasterInfo::VT_EXTRA, static_cast<int8_t>(extra), 0);
  }
  explicit RasterInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RasterInfoBuilder &operator=(const RasterInfoBuilder &);
  flatbuffers::Offset<RasterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RasterInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RasterInfo> CreateRasterInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Region>>> regions = 0,
    ExtraType extra = ExtraType_Normal) {
  RasterInfoBuilder builder_(_fbb);
  builder_.add_regions(regions);
  builder_.add_extra(extra);
  return builder_.Finish();
}

inline flatbuffers::Offset<RasterInfo> CreateRasterInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Region>> *regions = nullptr,
    ExtraType extra = ExtraType_Normal) {
  auto regions__ = regions ? _fbb.CreateVector<flatbuffers::Offset<Region>>(*regions) : 0;
  return MNNTRTPlugin::CreateRasterInfo(
      _fbb,
      regions__,
      extra);
}

flatbuffers::Offset<RasterInfo> CreateRasterInfo(flatbuffers::FlatBufferBuilder &_fbb, const RasterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShapeT : public flatbuffers::NativeTable {
  typedef Shape TableType;
  std::vector<int32_t> dim;
  int8_t bytes;
  int8_t type;
  ShapeT()
      : bytes(4),
        type(2) {
  }
};

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ShapeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_BYTES = 6,
    VT_TYPE = 8
  };
  const flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  int8_t bytes() const {
    return GetField<int8_t>(VT_BYTES, 4);
  }
  int8_t type() const {
    return GetField<int8_t>(VT_TYPE, 2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<int8_t>(verifier, VT_BYTES) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
  ShapeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Shape> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(Shape::VT_DIM, dim);
  }
  void add_bytes(int8_t bytes) {
    fbb_.AddElement<int8_t>(Shape::VT_BYTES, bytes, 4);
  }
  void add_type(int8_t type) {
    fbb_.AddElement<int8_t>(Shape::VT_TYPE, type, 2);
  }
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeBuilder &operator=(const ShapeBuilder &);
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dim = 0,
    int8_t bytes = 4,
    int8_t type = 2) {
  ShapeBuilder builder_(_fbb);
  builder_.add_dim(dim);
  builder_.add_type(type);
  builder_.add_bytes(bytes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shape> CreateShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dim = nullptr,
    int8_t bytes = 4,
    int8_t type = 2) {
  auto dim__ = dim ? _fbb.CreateVector<int32_t>(*dim) : 0;
  return MNNTRTPlugin::CreateShape(
      _fbb,
      dim__,
      bytes,
      type);
}

flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PluginT : public flatbuffers::NativeTable {
  typedef Plugin TableType;
  ParameterUnion main;
  std::vector<std::unique_ptr<ShapeT>> outputs;
  PluginT() {
  }
};

struct Plugin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PluginT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PluginTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAIN_TYPE = 4,
    VT_MAIN = 6,
    VT_OUTPUTS = 8
  };
  Parameter main_type() const {
    return static_cast<Parameter>(GetField<uint8_t>(VT_MAIN_TYPE, 0));
  }
  const void *main() const {
    return GetPointer<const void *>(VT_MAIN);
  }
  template<typename T> const T *main_as() const;
  const RasterInfo *main_as_RasterInfo() const {
    return main_type() == Parameter_RasterInfo ? static_cast<const RasterInfo *>(main()) : nullptr;
  }
  const BroadCastInfo *main_as_BroadCastInfo() const {
    return main_type() == Parameter_BroadCastInfo ? static_cast<const BroadCastInfo *>(main()) : nullptr;
  }
  const ScatterNdInfo *main_as_ScatterNdInfo() const {
    return main_type() == Parameter_ScatterNdInfo ? static_cast<const ScatterNdInfo *>(main()) : nullptr;
  }
  const InterpInfo *main_as_InterpInfo() const {
    return main_type() == Parameter_InterpInfo ? static_cast<const InterpInfo *>(main()) : nullptr;
  }
  const GatherInfo *main_as_GatherInfo() const {
    return main_type() == Parameter_GatherInfo ? static_cast<const GatherInfo *>(main()) : nullptr;
  }
  const DetectionPostProcessInfo *main_as_DetectionPostProcessInfo() const {
    return main_type() == Parameter_DetectionPostProcessInfo ? static_cast<const DetectionPostProcessInfo *>(main()) : nullptr;
  }
  const OneHotInfo *main_as_OneHotInfo() const {
    return main_type() == Parameter_OneHotInfo ? static_cast<const OneHotInfo *>(main()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Shape>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Shape>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAIN_TYPE) &&
           VerifyOffset(verifier, VT_MAIN) &&
           VerifyParameter(verifier, main(), main_type()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           verifier.EndTable();
  }
  PluginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PluginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Plugin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PluginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const RasterInfo *Plugin::main_as<RasterInfo>() const {
  return main_as_RasterInfo();
}

template<> inline const BroadCastInfo *Plugin::main_as<BroadCastInfo>() const {
  return main_as_BroadCastInfo();
}

template<> inline const ScatterNdInfo *Plugin::main_as<ScatterNdInfo>() const {
  return main_as_ScatterNdInfo();
}

template<> inline const InterpInfo *Plugin::main_as<InterpInfo>() const {
  return main_as_InterpInfo();
}

template<> inline const GatherInfo *Plugin::main_as<GatherInfo>() const {
  return main_as_GatherInfo();
}

template<> inline const DetectionPostProcessInfo *Plugin::main_as<DetectionPostProcessInfo>() const {
  return main_as_DetectionPostProcessInfo();
}

template<> inline const OneHotInfo *Plugin::main_as<OneHotInfo>() const {
  return main_as_OneHotInfo();
}

struct PluginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_main_type(Parameter main_type) {
    fbb_.AddElement<uint8_t>(Plugin::VT_MAIN_TYPE, static_cast<uint8_t>(main_type), 0);
  }
  void add_main(flatbuffers::Offset<void> main) {
    fbb_.AddOffset(Plugin::VT_MAIN, main);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shape>>> outputs) {
    fbb_.AddOffset(Plugin::VT_OUTPUTS, outputs);
  }
  explicit PluginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PluginBuilder &operator=(const PluginBuilder &);
  flatbuffers::Offset<Plugin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Plugin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Plugin> CreatePlugin(
    flatbuffers::FlatBufferBuilder &_fbb,
    Parameter main_type = Parameter_NONE,
    flatbuffers::Offset<void> main = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shape>>> outputs = 0) {
  PluginBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_main(main);
  builder_.add_main_type(main_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Plugin> CreatePluginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Parameter main_type = Parameter_NONE,
    flatbuffers::Offset<void> main = 0,
    const std::vector<flatbuffers::Offset<Shape>> *outputs = nullptr) {
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<Shape>>(*outputs) : 0;
  return MNNTRTPlugin::CreatePlugin(
      _fbb,
      main_type,
      main,
      outputs__);
}

flatbuffers::Offset<Plugin> CreatePlugin(flatbuffers::FlatBufferBuilder &_fbb, const PluginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ViewT *View::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ViewT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void View::UnPackTo(ViewT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = offset(); _o->offset = _e; };
  { auto _e = stride(); if (_e) { _o->stride.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stride[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<View> View::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateView(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<View> CreateView(flatbuffers::FlatBufferBuilder &_fbb, const ViewT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ViewT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _offset = _o->offset;
  auto _stride = _o->stride.size() ? _fbb.CreateVector(_o->stride) : 0;
  return MNNTRTPlugin::CreateView(
      _fbb,
      _offset,
      _stride);
}

inline RegionT *Region::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RegionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Region::UnPackTo(RegionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = src(); if (_e) _o->src = std::unique_ptr<ViewT>(_e->UnPack(_resolver)); };
  { auto _e = dst(); if (_e) _o->dst = std::unique_ptr<ViewT>(_e->UnPack(_resolver)); };
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } };
  { auto _e = index(); _o->index = _e; };
}

inline flatbuffers::Offset<Region> Region::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RegionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRegion(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Region> CreateRegion(flatbuffers::FlatBufferBuilder &_fbb, const RegionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RegionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _src = _o->src ? CreateView(_fbb, _o->src.get(), _rehasher) : 0;
  auto _dst = _o->dst ? CreateView(_fbb, _o->dst.get(), _rehasher) : 0;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  auto _index = _o->index;
  return MNNTRTPlugin::CreateRegion(
      _fbb,
      _src,
      _dst,
      _size,
      _index);
}

inline InterpInfoT *InterpInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new InterpInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void InterpInfo::UnPackTo(InterpInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = inputChannel(); _o->inputChannel = _e; };
  { auto _e = heightScale(); _o->heightScale = _e; };
  { auto _e = widthScale(); _o->widthScale = _e; };
  { auto _e = channelBlocks(); _o->channelBlocks = _e; };
  { auto _e = outputWidth(); _o->outputWidth = _e; };
  { auto _e = outputH_N(); _o->outputH_N = _e; };
  { auto _e = inputHeight(); _o->inputHeight = _e; };
  { auto _e = inputWidth(); _o->inputWidth = _e; };
  { auto _e = outputHeight(); _o->outputHeight = _e; };
}

inline flatbuffers::Offset<InterpInfo> InterpInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InterpInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInterpInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InterpInfo> CreateInterpInfo(flatbuffers::FlatBufferBuilder &_fbb, const InterpInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InterpInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _inputChannel = _o->inputChannel;
  auto _heightScale = _o->heightScale;
  auto _widthScale = _o->widthScale;
  auto _channelBlocks = _o->channelBlocks;
  auto _outputWidth = _o->outputWidth;
  auto _outputH_N = _o->outputH_N;
  auto _inputHeight = _o->inputHeight;
  auto _inputWidth = _o->inputWidth;
  auto _outputHeight = _o->outputHeight;
  return MNNTRTPlugin::CreateInterpInfo(
      _fbb,
      _inputChannel,
      _heightScale,
      _widthScale,
      _channelBlocks,
      _outputWidth,
      _outputH_N,
      _inputHeight,
      _inputWidth,
      _outputHeight);
}

inline GatherInfoT *GatherInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GatherInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GatherInfo::UnPackTo(GatherInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = limit(); _o->limit = _e; };
  { auto _e = insideStride(); _o->insideStride = _e; };
  { auto _e = N(); _o->N = _e; };
  { auto _e = outputOutsideStride(); _o->outputOutsideStride = _e; };
  { auto _e = inputOutsideStride(); _o->inputOutsideStride = _e; };
  { auto _e = outside(); _o->outside = _e; };
  { auto _e = input3(); _o->input3 = _e; };
}

inline flatbuffers::Offset<GatherInfo> GatherInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GatherInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGatherInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GatherInfo> CreateGatherInfo(flatbuffers::FlatBufferBuilder &_fbb, const GatherInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GatherInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _limit = _o->limit;
  auto _insideStride = _o->insideStride;
  auto _N = _o->N;
  auto _outputOutsideStride = _o->outputOutsideStride;
  auto _inputOutsideStride = _o->inputOutsideStride;
  auto _outside = _o->outside;
  auto _input3 = _o->input3;
  return MNNTRTPlugin::CreateGatherInfo(
      _fbb,
      _limit,
      _insideStride,
      _N,
      _outputOutsideStride,
      _inputOutsideStride,
      _outside,
      _input3);
}

inline OneHotInfoT *OneHotInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OneHotInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void OneHotInfo::UnPackTo(OneHotInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = outerSize(); _o->outerSize = _e; };
  { auto _e = innerSize(); _o->innerSize = _e; };
}

inline flatbuffers::Offset<OneHotInfo> OneHotInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OneHotInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOneHotInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<OneHotInfo> CreateOneHotInfo(flatbuffers::FlatBufferBuilder &_fbb, const OneHotInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OneHotInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _outerSize = _o->outerSize;
  auto _innerSize = _o->innerSize;
  return MNNTRTPlugin::CreateOneHotInfo(
      _fbb,
      _outerSize,
      _innerSize);
}

inline DetectionPostProcessInfoT *DetectionPostProcessInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DetectionPostProcessInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DetectionPostProcessInfo::UnPackTo(DetectionPostProcessInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = numAnchors0(); _o->numAnchors0 = _e; };
  { auto _e = scaleValues(); if (_e) { _o->scaleValues.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scaleValues[_i] = _e->Get(_i); } } };
  { auto _e = numBoxes(); _o->numBoxes = _e; };
  { auto _e = boxCoordNum(); _o->boxCoordNum = _e; };
  { auto _e = anchorsCoordNum(); _o->anchorsCoordNum = _e; };
  { auto _e = numAnchors1(); _o->numAnchors1 = _e; };
  { auto _e = numClassWithBackground(); _o->numClassWithBackground = _e; };
  { auto _e = numClasses(); _o->numClasses = _e; };
  { auto _e = maxClassesPerAnchor(); _o->maxClassesPerAnchor = _e; };
  { auto _e = maxDetections(); _o->maxDetections = _e; };
  { auto _e = iouThreshold(); _o->iouThreshold = _e; };
  { auto _e = nmsScoreThreshold(); _o->nmsScoreThreshold = _e; };
}

inline flatbuffers::Offset<DetectionPostProcessInfo> DetectionPostProcessInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDetectionPostProcessInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DetectionPostProcessInfo> CreateDetectionPostProcessInfo(flatbuffers::FlatBufferBuilder &_fbb, const DetectionPostProcessInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DetectionPostProcessInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _numAnchors0 = _o->numAnchors0;
  auto _scaleValues = _o->scaleValues.size() ? _fbb.CreateVector(_o->scaleValues) : 0;
  auto _numBoxes = _o->numBoxes;
  auto _boxCoordNum = _o->boxCoordNum;
  auto _anchorsCoordNum = _o->anchorsCoordNum;
  auto _numAnchors1 = _o->numAnchors1;
  auto _numClassWithBackground = _o->numClassWithBackground;
  auto _numClasses = _o->numClasses;
  auto _maxClassesPerAnchor = _o->maxClassesPerAnchor;
  auto _maxDetections = _o->maxDetections;
  auto _iouThreshold = _o->iouThreshold;
  auto _nmsScoreThreshold = _o->nmsScoreThreshold;
  return MNNTRTPlugin::CreateDetectionPostProcessInfo(
      _fbb,
      _numAnchors0,
      _scaleValues,
      _numBoxes,
      _boxCoordNum,
      _anchorsCoordNum,
      _numAnchors1,
      _numClassWithBackground,
      _numClasses,
      _maxClassesPerAnchor,
      _maxDetections,
      _iouThreshold,
      _nmsScoreThreshold);
}

inline ScatterNdInfoT *ScatterNdInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ScatterNdInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ScatterNdInfo::UnPackTo(ScatterNdInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indicesLastDim(); _o->indicesLastDim = _e; };
  { auto _e = indexes(); _o->indexes = _e; };
  { auto _e = accNumber(); _o->accNumber = _e; };
  { auto _e = outElementSize(); _o->outElementSize = _e; };
  { auto _e = dimsToCount(); if (_e) { _o->dimsToCount.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dimsToCount[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<ScatterNdInfo> ScatterNdInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScatterNdInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScatterNdInfo> CreateScatterNdInfo(flatbuffers::FlatBufferBuilder &_fbb, const ScatterNdInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScatterNdInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indicesLastDim = _o->indicesLastDim;
  auto _indexes = _o->indexes;
  auto _accNumber = _o->accNumber;
  auto _outElementSize = _o->outElementSize;
  auto _dimsToCount = _o->dimsToCount.size() ? _fbb.CreateVector(_o->dimsToCount) : 0;
  return MNNTRTPlugin::CreateScatterNdInfo(
      _fbb,
      _indicesLastDim,
      _indexes,
      _accNumber,
      _outElementSize,
      _dimsToCount);
}

inline BroadCastInfoT *BroadCastInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BroadCastInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BroadCastInfo::UnPackTo(BroadCastInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = input0(); _o->input0 = _e; };
  { auto _e = input1(); _o->input1 = _e; };
}

inline flatbuffers::Offset<BroadCastInfo> BroadCastInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BroadCastInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBroadCastInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BroadCastInfo> CreateBroadCastInfo(flatbuffers::FlatBufferBuilder &_fbb, const BroadCastInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BroadCastInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _input0 = _o->input0;
  auto _input1 = _o->input1;
  return MNNTRTPlugin::CreateBroadCastInfo(
      _fbb,
      _input0,
      _input1);
}

inline RasterInfoT *RasterInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RasterInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RasterInfo::UnPackTo(RasterInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = regions(); if (_e) { _o->regions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->regions[_i] = std::unique_ptr<RegionT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = extra(); _o->extra = _e; };
}

inline flatbuffers::Offset<RasterInfo> RasterInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RasterInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRasterInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RasterInfo> CreateRasterInfo(flatbuffers::FlatBufferBuilder &_fbb, const RasterInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RasterInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _regions = _o->regions.size() ? _fbb.CreateVector<flatbuffers::Offset<Region>> (_o->regions.size(), [](size_t i, _VectorArgs *__va) { return CreateRegion(*__va->__fbb, __va->__o->regions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extra = _o->extra;
  return MNNTRTPlugin::CreateRasterInfo(
      _fbb,
      _regions,
      _extra);
}

inline ShapeT *Shape::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShapeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Shape::UnPackTo(ShapeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dim(); if (_e) { _o->dim.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dim[_i] = _e->Get(_i); } } };
  { auto _e = bytes(); _o->bytes = _e; };
  { auto _e = type(); _o->type = _e; };
}

inline flatbuffers::Offset<Shape> Shape::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShape(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Shape> CreateShape(flatbuffers::FlatBufferBuilder &_fbb, const ShapeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShapeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dim = _o->dim.size() ? _fbb.CreateVector(_o->dim) : 0;
  auto _bytes = _o->bytes;
  auto _type = _o->type;
  return MNNTRTPlugin::CreateShape(
      _fbb,
      _dim,
      _bytes,
      _type);
}

inline PluginT *Plugin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PluginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Plugin::UnPackTo(PluginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = main_type(); _o->main.type = _e; };
  { auto _e = main(); if (_e) _o->main.value = ParameterUnion::UnPack(_e, main_type(), _resolver); };
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = std::unique_ptr<ShapeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Plugin> Plugin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PluginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlugin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Plugin> CreatePlugin(flatbuffers::FlatBufferBuilder &_fbb, const PluginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PluginT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _main_type = _o->main.type;
  auto _main = _o->main.Pack(_fbb);
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector<flatbuffers::Offset<Shape>> (_o->outputs.size(), [](size_t i, _VectorArgs *__va) { return CreateShape(*__va->__fbb, __va->__o->outputs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MNNTRTPlugin::CreatePlugin(
      _fbb,
      _main_type,
      _main,
      _outputs);
}

inline bool VerifyParameter(flatbuffers::Verifier &verifier, const void *obj, Parameter type) {
  switch (type) {
    case Parameter_NONE: {
      return true;
    }
    case Parameter_RasterInfo: {
      auto ptr = reinterpret_cast<const RasterInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Parameter_BroadCastInfo: {
      auto ptr = reinterpret_cast<const BroadCastInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Parameter_ScatterNdInfo: {
      auto ptr = reinterpret_cast<const ScatterNdInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Parameter_InterpInfo: {
      auto ptr = reinterpret_cast<const InterpInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Parameter_GatherInfo: {
      auto ptr = reinterpret_cast<const GatherInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Parameter_DetectionPostProcessInfo: {
      auto ptr = reinterpret_cast<const DetectionPostProcessInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Parameter_OneHotInfo: {
      auto ptr = reinterpret_cast<const OneHotInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyParameter(
        verifier,  values->Get(i), types->GetEnum<Parameter>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ParameterUnion::UnPack(const void *obj, Parameter type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Parameter_RasterInfo: {
      auto ptr = reinterpret_cast<const RasterInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case Parameter_BroadCastInfo: {
      auto ptr = reinterpret_cast<const BroadCastInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case Parameter_ScatterNdInfo: {
      auto ptr = reinterpret_cast<const ScatterNdInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case Parameter_InterpInfo: {
      auto ptr = reinterpret_cast<const InterpInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case Parameter_GatherInfo: {
      auto ptr = reinterpret_cast<const GatherInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case Parameter_DetectionPostProcessInfo: {
      auto ptr = reinterpret_cast<const DetectionPostProcessInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    case Parameter_OneHotInfo: {
      auto ptr = reinterpret_cast<const OneHotInfo *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ParameterUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Parameter_RasterInfo: {
      auto ptr = reinterpret_cast<const RasterInfoT *>(value);
      return CreateRasterInfo(_fbb, ptr, _rehasher).Union();
    }
    case Parameter_BroadCastInfo: {
      auto ptr = reinterpret_cast<const BroadCastInfoT *>(value);
      return CreateBroadCastInfo(_fbb, ptr, _rehasher).Union();
    }
    case Parameter_ScatterNdInfo: {
      auto ptr = reinterpret_cast<const ScatterNdInfoT *>(value);
      return CreateScatterNdInfo(_fbb, ptr, _rehasher).Union();
    }
    case Parameter_InterpInfo: {
      auto ptr = reinterpret_cast<const InterpInfoT *>(value);
      return CreateInterpInfo(_fbb, ptr, _rehasher).Union();
    }
    case Parameter_GatherInfo: {
      auto ptr = reinterpret_cast<const GatherInfoT *>(value);
      return CreateGatherInfo(_fbb, ptr, _rehasher).Union();
    }
    case Parameter_DetectionPostProcessInfo: {
      auto ptr = reinterpret_cast<const DetectionPostProcessInfoT *>(value);
      return CreateDetectionPostProcessInfo(_fbb, ptr, _rehasher).Union();
    }
    case Parameter_OneHotInfo: {
      auto ptr = reinterpret_cast<const OneHotInfoT *>(value);
      return CreateOneHotInfo(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ParameterUnion::ParameterUnion(const ParameterUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Parameter_RasterInfo: {
      FLATBUFFERS_ASSERT(false);  // RasterInfoT not copyable.
      break;
    }
    case Parameter_BroadCastInfo: {
      value = new BroadCastInfoT(*reinterpret_cast<BroadCastInfoT *>(u.value));
      break;
    }
    case Parameter_ScatterNdInfo: {
      value = new ScatterNdInfoT(*reinterpret_cast<ScatterNdInfoT *>(u.value));
      break;
    }
    case Parameter_InterpInfo: {
      value = new InterpInfoT(*reinterpret_cast<InterpInfoT *>(u.value));
      break;
    }
    case Parameter_GatherInfo: {
      value = new GatherInfoT(*reinterpret_cast<GatherInfoT *>(u.value));
      break;
    }
    case Parameter_DetectionPostProcessInfo: {
      value = new DetectionPostProcessInfoT(*reinterpret_cast<DetectionPostProcessInfoT *>(u.value));
      break;
    }
    case Parameter_OneHotInfo: {
      value = new OneHotInfoT(*reinterpret_cast<OneHotInfoT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ParameterUnion::Reset() {
  switch (type) {
    case Parameter_RasterInfo: {
      auto ptr = reinterpret_cast<RasterInfoT *>(value);
      delete ptr;
      break;
    }
    case Parameter_BroadCastInfo: {
      auto ptr = reinterpret_cast<BroadCastInfoT *>(value);
      delete ptr;
      break;
    }
    case Parameter_ScatterNdInfo: {
      auto ptr = reinterpret_cast<ScatterNdInfoT *>(value);
      delete ptr;
      break;
    }
    case Parameter_InterpInfo: {
      auto ptr = reinterpret_cast<InterpInfoT *>(value);
      delete ptr;
      break;
    }
    case Parameter_GatherInfo: {
      auto ptr = reinterpret_cast<GatherInfoT *>(value);
      delete ptr;
      break;
    }
    case Parameter_DetectionPostProcessInfo: {
      auto ptr = reinterpret_cast<DetectionPostProcessInfoT *>(value);
      delete ptr;
      break;
    }
    case Parameter_OneHotInfo: {
      auto ptr = reinterpret_cast<OneHotInfoT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Parameter_NONE;
}

inline const flatbuffers::TypeTable *ExtraTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ExtraTypeTypeTable
  };
  static const char * const names[] = {
    "Normal",
    "Fill"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ParameterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RasterInfoTypeTable,
    BroadCastInfoTypeTable,
    ScatterNdInfoTypeTable,
    InterpInfoTypeTable,
    GatherInfoTypeTable,
    DetectionPostProcessInfoTypeTable,
    OneHotInfoTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "RasterInfo",
    "BroadCastInfo",
    "ScatterNdInfo",
    "InterpInfo",
    "GatherInfo",
    "DetectionPostProcessInfo",
    "OneHotInfo"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 8, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ViewTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "offset",
    "stride"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RegionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ViewTypeTable
  };
  static const char * const names[] = {
    "src",
    "dst",
    "size",
    "index"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *InterpInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "inputChannel",
    "heightScale",
    "widthScale",
    "channelBlocks",
    "outputWidth",
    "outputH_N",
    "inputHeight",
    "inputWidth",
    "outputHeight"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GatherInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "limit",
    "insideStride",
    "N",
    "outputOutsideStride",
    "inputOutsideStride",
    "outside",
    "input3"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 7, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OneHotInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "outerSize",
    "innerSize"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DetectionPostProcessInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const char * const names[] = {
    "numAnchors0",
    "scaleValues",
    "numBoxes",
    "boxCoordNum",
    "anchorsCoordNum",
    "numAnchors1",
    "numClassWithBackground",
    "numClasses",
    "maxClassesPerAnchor",
    "maxDetections",
    "iouThreshold",
    "nmsScoreThreshold"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 12, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ScatterNdInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 }
  };
  static const char * const names[] = {
    "indicesLastDim",
    "indexes",
    "accNumber",
    "outElementSize",
    "dimsToCount"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BroadCastInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "input0",
    "input1"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RasterInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    RegionTypeTable,
    ExtraTypeTypeTable
  };
  static const char * const names[] = {
    "regions",
    "extra"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ShapeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, -1 },
    { flatbuffers::ET_CHAR, 0, -1 }
  };
  static const char * const names[] = {
    "dim",
    "bytes",
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *PluginTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ParameterTypeTable,
    ShapeTypeTable
  };
  static const char * const names[] = {
    "main_type",
    "main",
    "outputs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const MNNTRTPlugin::Plugin *GetPlugin(const void *buf) {
  return flatbuffers::GetRoot<MNNTRTPlugin::Plugin>(buf);
}

inline const MNNTRTPlugin::Plugin *GetSizePrefixedPlugin(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MNNTRTPlugin::Plugin>(buf);
}

inline bool VerifyPluginBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MNNTRTPlugin::Plugin>(nullptr);
}

inline bool VerifySizePrefixedPluginBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MNNTRTPlugin::Plugin>(nullptr);
}

inline void FinishPluginBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MNNTRTPlugin::Plugin> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPluginBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MNNTRTPlugin::Plugin> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<PluginT> UnPackPlugin(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<PluginT>(GetPlugin(buf)->UnPack(res));
}

}  // namespace MNNTRTPlugin

#endif  // FLATBUFFERS_GENERATED_MNNPLUGIN_MNNTRTPLUGIN_H_
