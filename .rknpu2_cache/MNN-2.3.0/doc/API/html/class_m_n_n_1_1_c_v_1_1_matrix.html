<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MNN: MNN::CV::Matrix类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MNN
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','搜索');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_m_n_n.html">MNN</a></li><li class="navelem"><a class="el" href="namespace_m_n_n_1_1_c_v.html">CV</a></li><li class="navelem"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pub-static-attribs">静态 Public 属性</a> &#124;
<a href="#friends">友元</a> &#124;
<a href="class_m_n_n_1_1_c_v_1_1_matrix-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">MNN::CV::Matrix类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_matrix_8h_source.html">Matrix.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a4d66f9e294a7bf8fcd111568f7f096c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3">TypeMask</a> { <br />
&#160;&#160;<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3a7c9c1f245488e9304bad456dba786b91">kIdentity_Mask</a> = 0, 
<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3a310a4123e7192b899ad0f68ed1b6f38f">kTranslate_Mask</a> = 0x01, 
<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3a6f6bedaa06c972b92fcd81ef9619e702">kScale_Mask</a> = 0x02, 
<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3a6f3fcf03cf1d72ebbcf19c7013376c0c">kAffine_Mask</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3a3658085367eabd3791636278654aab19">kPerspective_Mask</a> = 0x08
<br />
 }</td></tr>
<tr class="separator:a4d66f9e294a7bf8fcd111568f7f096c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c57512b9ff170b8c27141ac9dc2b16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16">ScaleToFit</a> { <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16a72d6657e24aae9858f946dcc8d638538">kFill_ScaleToFit</a>, 
<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16a7ecd2ad82e428b97949ce05fb72d2bb7">kStart_ScaleToFit</a>, 
<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16aae2bd4bf3c03002dc0011669a9125a95">kCenter_ScaleToFit</a>, 
<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16ad8816240d08e10c1dc565d0218a927cd">kEnd_ScaleToFit</a>
 }</td></tr>
<tr class="separator:ac4c57512b9ff170b8c27141ac9dc2b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a994a4f0be12f2881186892d123f83026"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a994a4f0be12f2881186892d123f83026">Matrix</a> ()</td></tr>
<tr class="separator:a994a4f0be12f2881186892d123f83026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920af77c5e089af12f9884583216ee89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3">TypeMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a920af77c5e089af12f9884583216ee89">getType</a> () const</td></tr>
<tr class="separator:a920af77c5e089af12f9884583216ee89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a9efb21f22e19461a7f15f41c7e301"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a80a9efb21f22e19461a7f15f41c7e301">isIdentity</a> () const</td></tr>
<tr class="separator:a80a9efb21f22e19461a7f15f41c7e301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7d34b3eb6adb9ec940827edf03082b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a1e7d34b3eb6adb9ec940827edf03082b">isScaleTranslate</a> () const</td></tr>
<tr class="separator:a1e7d34b3eb6adb9ec940827edf03082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c20c9a4df9dbe0d602271baa2fae8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af7c20c9a4df9dbe0d602271baa2fae8c">isTranslate</a> () const</td></tr>
<tr class="separator:af7c20c9a4df9dbe0d602271baa2fae8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4f4671dcd3eb69251b6b69b756c8eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aae4f4671dcd3eb69251b6b69b756c8eb">rectStaysRect</a> () const</td></tr>
<tr class="separator:aae4f4671dcd3eb69251b6b69b756c8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe9863cb0f149e97c57e0bd310a8091"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a0fe9863cb0f149e97c57e0bd310a8091">preservesAxisAlignment</a> () const</td></tr>
<tr class="separator:a0fe9863cb0f149e97c57e0bd310a8091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d75cd8885bc169ebbed0a3842d0a136"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a6d75cd8885bc169ebbed0a3842d0a136">operator[]</a> (int index) const</td></tr>
<tr class="separator:a6d75cd8885bc169ebbed0a3842d0a136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb83b8451e52f04224a2f10a8d7e977"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a8cb83b8451e52f04224a2f10a8d7e977">get</a> (int index) const</td></tr>
<tr class="separator:a8cb83b8451e52f04224a2f10a8d7e977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda91b2de2547c56812a990b343adea8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#afda91b2de2547c56812a990b343adea8">getScaleX</a> () const</td></tr>
<tr class="separator:afda91b2de2547c56812a990b343adea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3f83534c38eec1c605c143db5e440"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aebb3f83534c38eec1c605c143db5e440">getScaleY</a> () const</td></tr>
<tr class="separator:aebb3f83534c38eec1c605c143db5e440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4b603b48253e55fc27c2677898fe18"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4a4b603b48253e55fc27c2677898fe18">getSkewY</a> () const</td></tr>
<tr class="separator:a4a4b603b48253e55fc27c2677898fe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a50cf880189f8828cbe643c20086c36"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a7a50cf880189f8828cbe643c20086c36">getSkewX</a> () const</td></tr>
<tr class="separator:a7a50cf880189f8828cbe643c20086c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e21da1f6a1342a1e7c3f060d96af4d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af6e21da1f6a1342a1e7c3f060d96af4d">getTranslateX</a> () const</td></tr>
<tr class="separator:af6e21da1f6a1342a1e7c3f060d96af4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8312ffc5455b9217d8a3f3975237c026"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a8312ffc5455b9217d8a3f3975237c026">getTranslateY</a> () const</td></tr>
<tr class="separator:a8312ffc5455b9217d8a3f3975237c026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8ffb32f8988f89960254e982d5bc87"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a5f8ffb32f8988f89960254e982d5bc87">getPerspX</a> () const</td></tr>
<tr class="separator:a5f8ffb32f8988f89960254e982d5bc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dce01735b6ee0eddf90ee71d7eadf2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a63dce01735b6ee0eddf90ee71d7eadf2">getPerspY</a> () const</td></tr>
<tr class="separator:a63dce01735b6ee0eddf90ee71d7eadf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70b003dcbc742777bb908511be6fd63"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ab70b003dcbc742777bb908511be6fd63">operator[]</a> (int index)</td></tr>
<tr class="separator:ab70b003dcbc742777bb908511be6fd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95657f702e16d797477c9aa24ac4a0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a95657f702e16d797477c9aa24ac4a0fd">set</a> (int index, float value)</td></tr>
<tr class="separator:a95657f702e16d797477c9aa24ac4a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef2a1e031dd5de7ff653038c401c1d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a2ef2a1e031dd5de7ff653038c401c1d4">setScaleX</a> (float v)</td></tr>
<tr class="separator:a2ef2a1e031dd5de7ff653038c401c1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536b3ee8befe547496e47bef9422ca22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a536b3ee8befe547496e47bef9422ca22">setScaleY</a> (float v)</td></tr>
<tr class="separator:a536b3ee8befe547496e47bef9422ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28974d70ccb159f0c79ebc46f73fdfde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a28974d70ccb159f0c79ebc46f73fdfde">setSkewY</a> (float v)</td></tr>
<tr class="separator:a28974d70ccb159f0c79ebc46f73fdfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7c43a69da5564fade1134e245e5e65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a0e7c43a69da5564fade1134e245e5e65">setSkewX</a> (float v)</td></tr>
<tr class="separator:a0e7c43a69da5564fade1134e245e5e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea25177ca15b3e66b796811ff12839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aafea25177ca15b3e66b796811ff12839">setTranslateX</a> (float v)</td></tr>
<tr class="separator:aafea25177ca15b3e66b796811ff12839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af906c3d8207529707974d551d329ce39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af906c3d8207529707974d551d329ce39">setTranslateY</a> (float v)</td></tr>
<tr class="separator:af906c3d8207529707974d551d329ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07d0f297600849a05dc3b175098121e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac07d0f297600849a05dc3b175098121e">setPerspX</a> (float v)</td></tr>
<tr class="separator:ac07d0f297600849a05dc3b175098121e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387100b9690549b671cf69a82cc134d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a387100b9690549b671cf69a82cc134d1">setPerspY</a> (float v)</td></tr>
<tr class="separator:a387100b9690549b671cf69a82cc134d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c5adfb5b4236e756b95884de47c985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a41c5adfb5b4236e756b95884de47c985">setAll</a> (float scaleX, float skewX, float transX, float skewY, float scaleY, float transY, float persp0, float persp1, float persp2)</td></tr>
<tr class="separator:a41c5adfb5b4236e756b95884de47c985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e02d4d6e16ccdb49029aa44bab08330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a2e02d4d6e16ccdb49029aa44bab08330">get9</a> (float buffer[9]) const</td></tr>
<tr class="separator:a2e02d4d6e16ccdb49029aa44bab08330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb7b8bdb02f9cf2bbb4cc219cddb427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a8eb7b8bdb02f9cf2bbb4cc219cddb427">set9</a> (const float buffer[9])</td></tr>
<tr class="separator:a8eb7b8bdb02f9cf2bbb4cc219cddb427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361d0f247ef268c716f3575c2c46c640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a361d0f247ef268c716f3575c2c46c640">reset</a> ()</td></tr>
<tr class="separator:a361d0f247ef268c716f3575c2c46c640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46ca718c770bba11643c0ecc9a402fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad46ca718c770bba11643c0ecc9a402fa">setIdentity</a> ()</td></tr>
<tr class="separator:ad46ca718c770bba11643c0ecc9a402fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ddd5b5f07a3c7671502769cf95ecf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a64ddd5b5f07a3c7671502769cf95ecf8">setTranslate</a> (float dx, float dy)</td></tr>
<tr class="separator:a64ddd5b5f07a3c7671502769cf95ecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c757775b188138cf0b89f2cfd7f2fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a32c757775b188138cf0b89f2cfd7f2fd">setScale</a> (float sx, float sy, float px, float py)</td></tr>
<tr class="separator:a32c757775b188138cf0b89f2cfd7f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0147d1531b8456bc52a0a21b55b218f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad0147d1531b8456bc52a0a21b55b218f">setScale</a> (float sx, float sy)</td></tr>
<tr class="separator:ad0147d1531b8456bc52a0a21b55b218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbd6f23823704e5433fb701bce11717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#afdbd6f23823704e5433fb701bce11717">setRotate</a> (float degrees, float px, float py)</td></tr>
<tr class="separator:afdbd6f23823704e5433fb701bce11717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682f1252147fc991ce77e1ca185bf667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a682f1252147fc991ce77e1ca185bf667">setRotate</a> (float degrees)</td></tr>
<tr class="separator:a682f1252147fc991ce77e1ca185bf667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6ab1013e446d78b973a8bdfabff985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a6d6ab1013e446d78b973a8bdfabff985">setSinCos</a> (float sinValue, float cosValue, float px, float py)</td></tr>
<tr class="separator:a6d6ab1013e446d78b973a8bdfabff985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63971f3c3729080655b490def47ef017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a63971f3c3729080655b490def47ef017">setSinCos</a> (float sinValue, float cosValue)</td></tr>
<tr class="separator:a63971f3c3729080655b490def47ef017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954006adc7c06d5c64c6a6092ca88de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a954006adc7c06d5c64c6a6092ca88de7">setSkew</a> (float kx, float ky, float px, float py)</td></tr>
<tr class="separator:a954006adc7c06d5c64c6a6092ca88de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbb54180ce88853fb112113dc6d539c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a9bbb54180ce88853fb112113dc6d539c">setSkew</a> (float kx, float ky)</td></tr>
<tr class="separator:a9bbb54180ce88853fb112113dc6d539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e76afc5160219aa3c331cd2263d622c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a2e76afc5160219aa3c331cd2263d622c">setConcat</a> (const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;a, const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="separator:a2e76afc5160219aa3c331cd2263d622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedde66440e16fcf22fb5024dfafa4dbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aedde66440e16fcf22fb5024dfafa4dbf">preTranslate</a> (float dx, float dy)</td></tr>
<tr class="separator:aedde66440e16fcf22fb5024dfafa4dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0c4dca4efbd6a9db3e8ded2719e625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a9f0c4dca4efbd6a9db3e8ded2719e625">preScale</a> (float sx, float sy, float px, float py)</td></tr>
<tr class="separator:a9f0c4dca4efbd6a9db3e8ded2719e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58e079f0d2779cdcc46ec8e0662e796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ab58e079f0d2779cdcc46ec8e0662e796">preScale</a> (float sx, float sy)</td></tr>
<tr class="separator:ab58e079f0d2779cdcc46ec8e0662e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d1dbd3d7038bf452d65cea53f86c2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af8d1dbd3d7038bf452d65cea53f86c2a">preRotate</a> (float degrees, float px, float py)</td></tr>
<tr class="separator:af8d1dbd3d7038bf452d65cea53f86c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1a12516675c9d22b82ebe946f66d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#abc1a12516675c9d22b82ebe946f66d08">preRotate</a> (float degrees)</td></tr>
<tr class="separator:abc1a12516675c9d22b82ebe946f66d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea95454829f1ceb48ac0cb42a253b11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a7ea95454829f1ceb48ac0cb42a253b11">preSkew</a> (float kx, float ky, float px, float py)</td></tr>
<tr class="separator:a7ea95454829f1ceb48ac0cb42a253b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05afb8f62ddbfceb8638e67ff40b17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a6f05afb8f62ddbfceb8638e67ff40b17">preSkew</a> (float kx, float ky)</td></tr>
<tr class="separator:a6f05afb8f62ddbfceb8638e67ff40b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09590e014a86e9c3eb55160b09550e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af09590e014a86e9c3eb55160b09550e2">preConcat</a> (const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;other)</td></tr>
<tr class="separator:af09590e014a86e9c3eb55160b09550e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b27c11657f122aa457c5d0fd8da777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a17b27c11657f122aa457c5d0fd8da777">postTranslate</a> (float dx, float dy)</td></tr>
<tr class="separator:a17b27c11657f122aa457c5d0fd8da777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad176573dae007d41b6f649b480c2f154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad176573dae007d41b6f649b480c2f154">postScale</a> (float sx, float sy, float px, float py)</td></tr>
<tr class="separator:ad176573dae007d41b6f649b480c2f154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4f46eb00c55466465fe9674adfd44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a7a4f46eb00c55466465fe9674adfd44b">postScale</a> (float sx, float sy)</td></tr>
<tr class="separator:a7a4f46eb00c55466465fe9674adfd44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebca3f0a5c0063e7c2e7841fafd5e07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a6ebca3f0a5c0063e7c2e7841fafd5e07">postIDiv</a> (int divx, int divy)</td></tr>
<tr class="separator:a6ebca3f0a5c0063e7c2e7841fafd5e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597b031b70c941779e251be9d74bbd22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a597b031b70c941779e251be9d74bbd22">postRotate</a> (float degrees, float px, float py)</td></tr>
<tr class="separator:a597b031b70c941779e251be9d74bbd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267277c69b7ff90aa1149b8e4ec39945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a267277c69b7ff90aa1149b8e4ec39945">postRotate</a> (float degrees)</td></tr>
<tr class="separator:a267277c69b7ff90aa1149b8e4ec39945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d52a24c46117fd7f9500449d71c6443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a3d52a24c46117fd7f9500449d71c6443">postSkew</a> (float kx, float ky, float px, float py)</td></tr>
<tr class="separator:a3d52a24c46117fd7f9500449d71c6443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7a662b6a506e25d7cc5c944191a108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4f7a662b6a506e25d7cc5c944191a108">postSkew</a> (float kx, float ky)</td></tr>
<tr class="separator:a4f7a662b6a506e25d7cc5c944191a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda26fa13f16bfc6dd310de0350eb1ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#adda26fa13f16bfc6dd310de0350eb1ba">postConcat</a> (const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;other)</td></tr>
<tr class="separator:adda26fa13f16bfc6dd310de0350eb1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9ff946b4145e71f40205c9c23d63c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#afe9ff946b4145e71f40205c9c23d63c7">setRectToRect</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;src, const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;dst, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16">ScaleToFit</a> stf)</td></tr>
<tr class="separator:afe9ff946b4145e71f40205c9c23d63c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf1dae7c5be328fabc69baae8c710a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#afcf1dae7c5be328fabc69baae8c710a9">setPolyToPoly</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> src[], const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> dst[], int count)</td></tr>
<tr class="separator:afcf1dae7c5be328fabc69baae8c710a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037d7599f234e75c0869302e10a3dd32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a037d7599f234e75c0869302e10a3dd32">invert</a> (<a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> *inverse) const</td></tr>
<tr class="separator:a037d7599f234e75c0869302e10a3dd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf8d36ec8a915941d2daf08b429bd3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aabf8d36ec8a915941d2daf08b429bd3d">asAffine</a> (float affine[6]) const</td></tr>
<tr class="separator:aabf8d36ec8a915941d2daf08b429bd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d8055f96099dfe15aeed62794b12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a163d8055f96099dfe15aeed62794b12f">setAffine</a> (const float affine[6])</td></tr>
<tr class="separator:a163d8055f96099dfe15aeed62794b12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dbff13c64c0ed0e9005b2609c550a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a93dbff13c64c0ed0e9005b2609c550a1">mapPoints</a> (<a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> dst[], const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> src[], int count) const</td></tr>
<tr class="separator:a93dbff13c64c0ed0e9005b2609c550a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c756e36573cc6ef1c4f77c3088eaee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ab7c756e36573cc6ef1c4f77c3088eaee">mapPoints</a> (<a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> pts[], int count) const</td></tr>
<tr class="separator:ab7c756e36573cc6ef1c4f77c3088eaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f97f8217503e8cb7ed70d2d54960a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a3f97f8217503e8cb7ed70d2d54960a54">mapXY</a> (float x, float y, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> *result) const</td></tr>
<tr class="separator:a3f97f8217503e8cb7ed70d2d54960a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d45157a305e7063765f534030163f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a0d45157a305e7063765f534030163f21">mapXY</a> (float x, float y) const</td></tr>
<tr class="separator:a0d45157a305e7063765f534030163f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd0b378ff8a6bd598db923cc8ccd2d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#affd0b378ff8a6bd598db923cc8ccd2d1">mapRect</a> (<a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> *dst, const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;src) const</td></tr>
<tr class="separator:affd0b378ff8a6bd598db923cc8ccd2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1d97cacdb68559670ed7ebd5a02b40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a2c1d97cacdb68559670ed7ebd5a02b40">mapRect</a> (<a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> *rect) const</td></tr>
<tr class="separator:a2c1d97cacdb68559670ed7ebd5a02b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549c7d38b10404a4b61043b140dfebdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a549c7d38b10404a4b61043b140dfebdc">mapRect</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;src) const</td></tr>
<tr class="separator:a549c7d38b10404a4b61043b140dfebdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd5666970c26af2d84725856d4d7086"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#afdd5666970c26af2d84725856d4d7086">mapRectScaleTranslate</a> (<a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> *dst, const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;src) const</td></tr>
<tr class="separator:afdd5666970c26af2d84725856d4d7086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67caa4d57647261577f3462efa1d27d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a67caa4d57647261577f3462efa1d27d1">cheapEqualTo</a> (const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;m) const</td></tr>
<tr class="separator:a67caa4d57647261577f3462efa1d27d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c8ab196c75af4f95a87d1edc4a5e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad6c8ab196c75af4f95a87d1edc4a5e3b">dump</a> () const</td></tr>
<tr class="separator:ad6c8ab196c75af4f95a87d1edc4a5e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff7f1066629e5bda770ad20eabf482b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a1ff7f1066629e5bda770ad20eabf482b">getMinScale</a> () const</td></tr>
<tr class="separator:a1ff7f1066629e5bda770ad20eabf482b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d2fc1d974f932f567cee7ba576794f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a07d2fc1d974f932f567cee7ba576794f">getMaxScale</a> () const</td></tr>
<tr class="separator:a07d2fc1d974f932f567cee7ba576794f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773feafa918dbac013107f9fd930f03f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a773feafa918dbac013107f9fd930f03f">getMinMaxScales</a> (float scaleFactors[2]) const</td></tr>
<tr class="separator:a773feafa918dbac013107f9fd930f03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68596240a7b1dded463fd642f9a3362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af68596240a7b1dded463fd642f9a3362">dirtyMatrixTypeCache</a> ()</td></tr>
<tr class="separator:af68596240a7b1dded463fd642f9a3362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900fc53c7e53893983ae6053ac2d98f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a9900fc53c7e53893983ae6053ac2d98f">setScaleTranslate</a> (float sx, float sy, float tx, float ty)</td></tr>
<tr class="separator:a9900fc53c7e53893983ae6053ac2d98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a85cd67b59f24ab307950b437c4669eae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a85cd67b59f24ab307950b437c4669eae">MakeScale</a> (float sx, float sy)</td></tr>
<tr class="separator:a85cd67b59f24ab307950b437c4669eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b05fbab55e352623bc6472a3a29b426"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a3b05fbab55e352623bc6472a3a29b426">MakeScale</a> (float scale)</td></tr>
<tr class="separator:a3b05fbab55e352623bc6472a3a29b426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a7c082d559ef73f93ec16e9644b590"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad0a7c082d559ef73f93ec16e9644b590">MakeTrans</a> (float dx, float dy)</td></tr>
<tr class="separator:ad0a7c082d559ef73f93ec16e9644b590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd03e03f146c891e3a7dd64cea4d09cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#afd03e03f146c891e3a7dd64cea4d09cc">MakeAll</a> (float scaleX, float skewX, float transX, float skewY, float scaleY, float transY, float pers0, float pers1, float pers2)</td></tr>
<tr class="separator:afd03e03f146c891e3a7dd64cea4d09cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a6fe8b976cae6f08d356855a5fd53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a012a6fe8b976cae6f08d356855a5fd53">MakeRectToRect</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;src, const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;dst, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16">ScaleToFit</a> stf)</td></tr>
<tr class="separator:a012a6fe8b976cae6f08d356855a5fd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee028c3ec7bef9b08ec31e16ef1db01b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aee028c3ec7bef9b08ec31e16ef1db01b">SetAffineIdentity</a> (float affine[6])</td></tr>
<tr class="separator:aee028c3ec7bef9b08ec31e16ef1db01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523322019ca469544f440ff6c8c3daa7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a523322019ca469544f440ff6c8c3daa7">I</a> ()</td></tr>
<tr class="separator:a523322019ca469544f440ff6c8c3daa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a9932f73bded08f47e21782ed60e63"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a88a9932f73bded08f47e21782ed60e63">InvalidMatrix</a> ()</td></tr>
<tr class="separator:a88a9932f73bded08f47e21782ed60e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7161b6a80fa3424019b029d29d084fc4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a7161b6a80fa3424019b029d29d084fc4">Concat</a> (const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;a, const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="separator:a7161b6a80fa3424019b029d29d084fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
静态 Public 属性</h2></td></tr>
<tr class="memitem:a7de74100127ba6292318d4105e2448e0"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a7de74100127ba6292318d4105e2448e0">kMScaleX</a> = 0</td></tr>
<tr class="memdesc:a7de74100127ba6292318d4105e2448e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal scale factor  <a href="#a7de74100127ba6292318d4105e2448e0">更多...</a><br /></td></tr>
<tr class="separator:a7de74100127ba6292318d4105e2448e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37665e4b858862fdc50366fac19ac7b1"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a37665e4b858862fdc50366fac19ac7b1">kMSkewX</a> = 1</td></tr>
<tr class="memdesc:a37665e4b858862fdc50366fac19ac7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal skew factor  <a href="#a37665e4b858862fdc50366fac19ac7b1">更多...</a><br /></td></tr>
<tr class="separator:a37665e4b858862fdc50366fac19ac7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d2de9bc274df21d07e0d30fb7f7a4"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a202d2de9bc274df21d07e0d30fb7f7a4">kMTransX</a> = 2</td></tr>
<tr class="memdesc:a202d2de9bc274df21d07e0d30fb7f7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal translation  <a href="#a202d2de9bc274df21d07e0d30fb7f7a4">更多...</a><br /></td></tr>
<tr class="separator:a202d2de9bc274df21d07e0d30fb7f7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d3c4f79dadfcde314f757430d46ae"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a254d3c4f79dadfcde314f757430d46ae">kMSkewY</a> = 3</td></tr>
<tr class="memdesc:a254d3c4f79dadfcde314f757430d46ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical skew factor  <a href="#a254d3c4f79dadfcde314f757430d46ae">更多...</a><br /></td></tr>
<tr class="separator:a254d3c4f79dadfcde314f757430d46ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0740678fdc865ecc7ffbe116fa4adb45"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a0740678fdc865ecc7ffbe116fa4adb45">kMScaleY</a> = 4</td></tr>
<tr class="memdesc:a0740678fdc865ecc7ffbe116fa4adb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical scale factor  <a href="#a0740678fdc865ecc7ffbe116fa4adb45">更多...</a><br /></td></tr>
<tr class="separator:a0740678fdc865ecc7ffbe116fa4adb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92341274274d04e3fd668843157ed393"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a92341274274d04e3fd668843157ed393">kMTransY</a> = 5</td></tr>
<tr class="memdesc:a92341274274d04e3fd668843157ed393"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical translation  <a href="#a92341274274d04e3fd668843157ed393">更多...</a><br /></td></tr>
<tr class="separator:a92341274274d04e3fd668843157ed393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89d5ae10e6a97e467805b7e67016071"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad89d5ae10e6a97e467805b7e67016071">kMPersp0</a> = 6</td></tr>
<tr class="memdesc:ad89d5ae10e6a97e467805b7e67016071"><td class="mdescLeft">&#160;</td><td class="mdescRight">input x perspective factor  <a href="#ad89d5ae10e6a97e467805b7e67016071">更多...</a><br /></td></tr>
<tr class="separator:ad89d5ae10e6a97e467805b7e67016071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5335529230f770344e12c15814a73040"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a5335529230f770344e12c15814a73040">kMPersp1</a> = 7</td></tr>
<tr class="memdesc:a5335529230f770344e12c15814a73040"><td class="mdescLeft">&#160;</td><td class="mdescRight">input y perspective factor  <a href="#a5335529230f770344e12c15814a73040">更多...</a><br /></td></tr>
<tr class="separator:a5335529230f770344e12c15814a73040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5f38e0114da2fb099852078743d7ad"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aef5f38e0114da2fb099852078743d7ad">kMPersp2</a> = 8</td></tr>
<tr class="memdesc:aef5f38e0114da2fb099852078743d7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">perspective bias  <a href="#aef5f38e0114da2fb099852078743d7ad">更多...</a><br /></td></tr>
<tr class="separator:aef5f38e0114da2fb099852078743d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e060cdf6868cdfdf0bae432aa17fd5"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ae8e060cdf6868cdfdf0bae432aa17fd5">kAScaleX</a> = 0</td></tr>
<tr class="memdesc:ae8e060cdf6868cdfdf0bae432aa17fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal scale factor  <a href="#ae8e060cdf6868cdfdf0bae432aa17fd5">更多...</a><br /></td></tr>
<tr class="separator:ae8e060cdf6868cdfdf0bae432aa17fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c71cf11a29bf7344357c28b4193545"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af9c71cf11a29bf7344357c28b4193545">kASkewY</a> = 1</td></tr>
<tr class="memdesc:af9c71cf11a29bf7344357c28b4193545"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical skew factor  <a href="#af9c71cf11a29bf7344357c28b4193545">更多...</a><br /></td></tr>
<tr class="separator:af9c71cf11a29bf7344357c28b4193545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb9dedcccbc251c9a412cf71f4e0b3c"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a0eb9dedcccbc251c9a412cf71f4e0b3c">kASkewX</a> = 2</td></tr>
<tr class="memdesc:a0eb9dedcccbc251c9a412cf71f4e0b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal skew factor  <a href="#a0eb9dedcccbc251c9a412cf71f4e0b3c">更多...</a><br /></td></tr>
<tr class="separator:a0eb9dedcccbc251c9a412cf71f4e0b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df867ef1512a44a8539d46e0acad6a9"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a2df867ef1512a44a8539d46e0acad6a9">kAScaleY</a> = 3</td></tr>
<tr class="memdesc:a2df867ef1512a44a8539d46e0acad6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical scale factor  <a href="#a2df867ef1512a44a8539d46e0acad6a9">更多...</a><br /></td></tr>
<tr class="separator:a2df867ef1512a44a8539d46e0acad6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ae3231629fc59390a63661edf1f447"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad5ae3231629fc59390a63661edf1f447">kATransX</a> = 4</td></tr>
<tr class="memdesc:ad5ae3231629fc59390a63661edf1f447"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal translation  <a href="#ad5ae3231629fc59390a63661edf1f447">更多...</a><br /></td></tr>
<tr class="separator:ad5ae3231629fc59390a63661edf1f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ee756b37c955f7935cee8ea0e29081"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a86ee756b37c955f7935cee8ea0e29081">kATransY</a> = 5</td></tr>
<tr class="memdesc:a86ee756b37c955f7935cee8ea0e29081"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical translation  <a href="#a86ee756b37c955f7935cee8ea0e29081">更多...</a><br /></td></tr>
<tr class="separator:a86ee756b37c955f7935cee8ea0e29081"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
友元</h2></td></tr>
<tr class="memitem:a86b790569aa79e9472f9863751e0d133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_m_n_n_define_8h.html#a692428e2a0af8ffb79376d223a0695ab">MNN_PUBLIC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a86b790569aa79e9472f9863751e0d133">operator==</a> (const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;a, const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="separator:a86b790569aa79e9472f9863751e0d133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2ab581fd780faf0c80cd3765fd3121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_m_n_n_define_8h.html#a692428e2a0af8ffb79376d223a0695ab">MNN_PUBLIC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a9a2ab581fd780faf0c80cd3765fd3121">operator!=</a> (const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;a, const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;b)</td></tr>
<tr class="separator:a9a2ab581fd780faf0c80cd3765fd3121"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> holds a 3x3 matrix for transforming coordinates. This allows mapping <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> and vectors with translation, scaling, skewing, rotation, and perspective.</p>
<p><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> elements are in row major order. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> does not have a constructor, so it must be explicitly initialized. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad46ca718c770bba11643c0ecc9a402fa">setIdentity()</a> initializes <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> so it has no effect. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a64ddd5b5f07a3c7671502769cf95ecf8">setTranslate()</a>, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a32c757775b188138cf0b89f2cfd7f2fd">setScale()</a>, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a954006adc7c06d5c64c6a6092ca88de7">setSkew()</a>, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#afdbd6f23823704e5433fb701bce11717">setRotate()</a>, set9 and <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a41c5adfb5b4236e756b95884de47c985">setAll()</a> initializes all <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> elements with the corresponding mapping.</p>
<p><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> includes a hidden variable that classifies the type of matrix to improve performance. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is not thread safe unless <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a920af77c5e089af12f9884583216ee89">getType()</a> is called first. </p>
</div><h2 class="groupheader">成员枚举类型说明</h2>
<a id="ac4c57512b9ff170b8c27141ac9dc2b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c57512b9ff170b8c27141ac9dc2b16">&#9670;&nbsp;</a></span>ScaleToFit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16">MNN::CV::Matrix::ScaleToFit</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="ac4c57512b9ff170b8c27141ac9dc2b16a72d6657e24aae9858f946dcc8d638538"></a>kFill_ScaleToFit&#160;</td><td class="fielddoc"><p>scales in x and y to fill destination <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ac4c57512b9ff170b8c27141ac9dc2b16a7ecd2ad82e428b97949ce05fb72d2bb7"></a>kStart_ScaleToFit&#160;</td><td class="fielddoc"><p>scales and aligns to left and top </p>
</td></tr>
<tr><td class="fieldname"><a id="ac4c57512b9ff170b8c27141ac9dc2b16aae2bd4bf3c03002dc0011669a9125a95"></a>kCenter_ScaleToFit&#160;</td><td class="fielddoc"><p>scales and aligns to center </p>
</td></tr>
<tr><td class="fieldname"><a id="ac4c57512b9ff170b8c27141ac9dc2b16ad8816240d08e10c1dc565d0218a927cd"></a>kEnd_ScaleToFit&#160;</td><td class="fielddoc"><p>scales and aligns to right and bottom </p>
</td></tr>
</table>

</div>
</div>
<a id="a4d66f9e294a7bf8fcd111568f7f096c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d66f9e294a7bf8fcd111568f7f096c3">&#9670;&nbsp;</a></span>TypeMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3">MNN::CV::Matrix::TypeMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a4d66f9e294a7bf8fcd111568f7f096c3a7c9c1f245488e9304bad456dba786b91"></a>kIdentity_Mask&#160;</td><td class="fielddoc"><p>identity <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>; all bits clear </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d66f9e294a7bf8fcd111568f7f096c3a310a4123e7192b899ad0f68ed1b6f38f"></a>kTranslate_Mask&#160;</td><td class="fielddoc"><p>translation <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d66f9e294a7bf8fcd111568f7f096c3a6f6bedaa06c972b92fcd81ef9619e702"></a>kScale_Mask&#160;</td><td class="fielddoc"><p>scale <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d66f9e294a7bf8fcd111568f7f096c3a6f3fcf03cf1d72ebbcf19c7013376c0c"></a>kAffine_Mask&#160;</td><td class="fielddoc"><p>skew or rotate <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d66f9e294a7bf8fcd111568f7f096c3a3658085367eabd3791636278654aab19"></a>kPerspective_Mask&#160;</td><td class="fielddoc"><p>perspective <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a994a4f0be12f2881186892d123f83026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994a4f0be12f2881186892d123f83026">&#9670;&nbsp;</a></span>Matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MNN::CV::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="aabf8d36ec8a915941d2daf08b429bd3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf8d36ec8a915941d2daf08b429bd3d">&#9670;&nbsp;</a></span>asAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::asAffine </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>affine</em>[6]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills affine in column major order. Sets affine to: </p><pre class="fragment">| scale-x  skew-x translate-x |
| skew-y  scale-y translate-y |
</pre><p>If <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> contains perspective, returns false and leaves affine unchanged.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">affine</td><td>storage for 3x2 affine matrix; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> does not contain perspective </dd></dl>

</div>
</div>
<a id="a67caa4d57647261577f3462efa1d27d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67caa4d57647261577f3462efa1d27d1">&#9670;&nbsp;</a></span>cheapEqualTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::cheapEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> equals m, using an efficient comparison.</p>
<p>Returns false when the sign of zero values is the different; when one matrix has positive zero value and the other has negative zero value.</p>
<p>Returns true even when both <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> contain NaN.</p>
<p>NaN never equals any value, including itself. To improve performance, NaN values are treated as bit patterns that are equal if their bit patterns are equal.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if m and <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> are represented by identical bit patterns </dd></dl>

</div>
</div>
<a id="a7161b6a80fa3424019b029d29d084fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7161b6a80fa3424019b029d29d084fc4">&#9670;&nbsp;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> MNN::CV::Matrix::Concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> a multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> b.</p>
<p>Given: </p><pre class="fragment">    | A B C |      | J K L |
a = | D E F |, b = | M N O |
    | G H I |      | P Q R |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">        | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
        | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> on left side of multiply expression </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> on right side of multiply expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> computed from a times b </dd></dl>

</div>
</div>
<a id="af68596240a7b1dded463fd642f9a3362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68596240a7b1dded463fd642f9a3362">&#9670;&nbsp;</a></span>dirtyMatrixTypeCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::dirtyMatrixTypeCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets internal cache to unknown state. Use to force update after repeated modifications to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> element reference returned by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ab70b003dcbc742777bb908511be6fd63">operator[](int index)</a>. </p>

</div>
</div>
<a id="ad6c8ab196c75af4f95a87d1edc4a5e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c8ab196c75af4f95a87d1edc4a5e3b">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes text representation of <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to standard output. Floating point values are written with limited precision; it may not be possible to reconstruct original <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> from output. </p>

</div>
</div>
<a id="a8cb83b8451e52f04224a2f10a8d7e977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb83b8451e52f04224a2f10a8d7e977">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one matrix value. Asserts if index is out of range and SK_DEBUG is defined.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>value corresponding to index </dd></dl>

</div>
</div>
<a id="a2e02d4d6e16ccdb49029aa44bab08330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e02d4d6e16ccdb49029aa44bab08330">&#9670;&nbsp;</a></span>get9()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::get9 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>buffer</em>[9]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies nine scalar values contained by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> into buffer, in member value ascending order: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>storage for nine scalar values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07d2fc1d974f932f567cee7ba576794f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d2fc1d974f932f567cee7ba576794f">&#9670;&nbsp;</a></span>getMaxScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getMaxScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum scaling factor of <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> by decomposing the scaling and skewing elements. Returns -1 if scale factor overflows or <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> contains perspective.</p>
<dl class="section return"><dt>返回</dt><dd>maximum scale factor </dd></dl>

</div>
</div>
<a id="a773feafa918dbac013107f9fd930f03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773feafa918dbac013107f9fd930f03f">&#9670;&nbsp;</a></span>getMinMaxScales()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::getMinMaxScales </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleFactors</em>[2]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets scaleFactors[0] to the minimum scaling factor, and scaleFactors[1] to the maximum scaling factor. Scaling factors are computed by decomposing the <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> scaling and skewing elements.</p>
<p>Returns true if scaleFactors are found; otherwise, returns false and sets scaleFactors to undefined values.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleFactors</td><td>storage for minimum and maximum scale factors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if scale factors were computed correctly </dd></dl>

</div>
</div>
<a id="a1ff7f1066629e5bda770ad20eabf482b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff7f1066629e5bda770ad20eabf482b">&#9670;&nbsp;</a></span>getMinScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getMinScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum scaling factor of <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> by decomposing the scaling and skewing elements. Returns -1 if scale factor overflows or <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> contains perspective.</p>
<dl class="section return"><dt>返回</dt><dd>minimum scale factor </dd></dl>

</div>
</div>
<a id="a5f8ffb32f8988f89960254e982d5bc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8ffb32f8988f89960254e982d5bc87">&#9670;&nbsp;</a></span>getPerspX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getPerspX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns factor scaling input x-axis relative to input y-axis.</p>
<dl class="section return"><dt>返回</dt><dd>input x-axis perspective factor </dd></dl>

</div>
</div>
<a id="a63dce01735b6ee0eddf90ee71d7eadf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dce01735b6ee0eddf90ee71d7eadf2">&#9670;&nbsp;</a></span>getPerspY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getPerspY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns factor scaling input y-axis relative to input x-axis.</p>
<dl class="section return"><dt>返回</dt><dd>input y-axis perspective factor </dd></dl>

</div>
</div>
<a id="afda91b2de2547c56812a990b343adea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda91b2de2547c56812a990b343adea8">&#9670;&nbsp;</a></span>getScaleX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getScaleX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by x-axis input, contributing to x-axis output. With <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a93dbff13c64c0ed0e9005b2609c550a1">mapPoints()</a>, scales <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> along the x-axis.</p>
<dl class="section return"><dt>返回</dt><dd>horizontal scale factor </dd></dl>

</div>
</div>
<a id="aebb3f83534c38eec1c605c143db5e440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3f83534c38eec1c605c143db5e440">&#9670;&nbsp;</a></span>getScaleY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getScaleY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by y-axis input, contributing to y-axis output. With <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a93dbff13c64c0ed0e9005b2609c550a1">mapPoints()</a>, scales <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> along the y-axis.</p>
<dl class="section return"><dt>返回</dt><dd>vertical scale factor </dd></dl>

</div>
</div>
<a id="a7a50cf880189f8828cbe643c20086c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a50cf880189f8828cbe643c20086c36">&#9670;&nbsp;</a></span>getSkewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getSkewX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by y-axis input, contributing to x-axis output. With <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a93dbff13c64c0ed0e9005b2609c550a1">mapPoints()</a>, skews <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> along the x-axis. Skewing both axes can rotate <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>.</p>
<dl class="section return"><dt>返回</dt><dd>horizontal scale factor </dd></dl>

</div>
</div>
<a id="a4a4b603b48253e55fc27c2677898fe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4b603b48253e55fc27c2677898fe18">&#9670;&nbsp;</a></span>getSkewY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getSkewY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by x-axis input, contributing to y-axis output. With <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a93dbff13c64c0ed0e9005b2609c550a1">mapPoints()</a>, skews <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> along the y-axis. Skewing both axes can rotate <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>.</p>
<dl class="section return"><dt>返回</dt><dd>vertical skew factor </dd></dl>

</div>
</div>
<a id="af6e21da1f6a1342a1e7c3f060d96af4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e21da1f6a1342a1e7c3f060d96af4d">&#9670;&nbsp;</a></span>getTranslateX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getTranslateX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns translation contributing to x-axis output. With <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a93dbff13c64c0ed0e9005b2609c550a1">mapPoints()</a>, moves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> along the x-axis.</p>
<dl class="section return"><dt>返回</dt><dd>horizontal translation factor </dd></dl>

</div>
</div>
<a id="a8312ffc5455b9217d8a3f3975237c026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8312ffc5455b9217d8a3f3975237c026">&#9670;&nbsp;</a></span>getTranslateY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::getTranslateY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns translation contributing to y-axis output. With <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a93dbff13c64c0ed0e9005b2609c550a1">mapPoints()</a>, moves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> along the y-axis.</p>
<dl class="section return"><dt>返回</dt><dd>vertical translation factor </dd></dl>

</div>
</div>
<a id="a920af77c5e089af12f9884583216ee89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920af77c5e089af12f9884583216ee89">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a4d66f9e294a7bf8fcd111568f7f096c3">TypeMask</a> MNN::CV::Matrix::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a bit field describing the transformations the matrix may perform. The bit field is computed conservatively, so it may include false positives. For example, when kPerspective_Mask is set, all other bits are set.</p>
<dl class="section return"><dt>返回</dt><dd>kIdentity_Mask, or combinations of: kTranslate_Mask, kScale_Mask, kAffine_Mask, kPerspective_Mask </dd></dl>

</div>
</div>
<a id="a523322019ca469544f440ff6c8c3daa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523322019ca469544f440ff6c8c3daa7">&#9670;&nbsp;</a></span>I()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&amp; MNN::CV::Matrix::I </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns reference to const identity <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. Returned <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is set to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><dl class="section return"><dt>返回</dt><dd>const identity <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </dd></dl>

</div>
</div>
<a id="a88a9932f73bded08f47e21782ed60e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a9932f73bded08f47e21782ed60e63">&#9670;&nbsp;</a></span>InvalidMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>&amp; MNN::CV::Matrix::InvalidMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns reference to a const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> with invalid values. Returned <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is set to: </p><pre class="fragment">| SK_ScalarMax SK_ScalarMax SK_ScalarMax |
| SK_ScalarMax SK_ScalarMax SK_ScalarMax |
| SK_ScalarMax SK_ScalarMax SK_ScalarMax |
</pre><dl class="section return"><dt>返回</dt><dd>const invalid <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </dd></dl>

</div>
</div>
<a id="a037d7599f234e75c0869302e10a3dd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037d7599f234e75c0869302e10a3dd32">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> *&#160;</td>
          <td class="paramname"><em>inverse</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets inverse to reciprocal matrix, returning true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> can be inverted. Geometrically, if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> maps from source to destination, inverse <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> maps from destination to source. If <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> can not be inverted, inverse is unchanged.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>storage for inverted <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> can be inverted </dd></dl>

</div>
</div>
<a id="a80a9efb21f22e19461a7f15f41c7e301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a9efb21f22e19461a7f15f41c7e301">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is identity. Identity matrix is: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> has no effect </dd></dl>

</div>
</div>
<a id="a1e7d34b3eb6adb9ec940827edf03082b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7d34b3eb6adb9ec940827edf03082b">&#9670;&nbsp;</a></span>isScaleTranslate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::isScaleTranslate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> at most scales and translates. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> may be identity, contain only scale elements, only translate elements, or both. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> form is: </p><pre class="fragment">| scale-x    0    translate-x |
|    0    scale-y translate-y |
|    0       0         1      |
</pre><dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is identity; or scales, translates, or both </dd></dl>

</div>
</div>
<a id="af7c20c9a4df9dbe0d602271baa2fae8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c20c9a4df9dbe0d602271baa2fae8c">&#9670;&nbsp;</a></span>isTranslate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::isTranslate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is identity, or translates. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> form is: </p><pre class="fragment">| 1 0 translate-x |
| 0 1 translate-y |
| 0 0      1      |
</pre><dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is identity, or translates </dd></dl>

</div>
</div>
<a id="afd03e03f146c891e3a7dd64cea4d09cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd03e03f146c891e3a7dd64cea4d09cc">&#9670;&nbsp;</a></span>MakeAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> MNN::CV::Matrix::MakeAll </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>transX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>transY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pers0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pers1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pers2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">| scaleX  skewX transX |
|  skewY scaleY transY |
|  pers0  pers1  pers2 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">skewX</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">transX</td><td>horizontal translation </td></tr>
    <tr><td class="paramname">skewY</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">scaleY</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">transY</td><td>vertical translation </td></tr>
    <tr><td class="paramname">pers0</td><td>input x-axis perspective factor </td></tr>
    <tr><td class="paramname">pers1</td><td>input y-axis perspective factor </td></tr>
    <tr><td class="paramname">pers2</td><td>perspective scale factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from parameters </dd></dl>

</div>
</div>
<a id="a012a6fe8b976cae6f08d356855a5fd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012a6fe8b976cae6f08d356855a5fd53">&#9670;&nbsp;</a></span>MakeRectToRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> MNN::CV::Matrix::MakeRectToRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16">ScaleToFit</a>&#160;</td>
          <td class="paramname"><em>stf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> set to scale and translate src <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to dst <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>. stf selects whether mapping completely fills dst or preserves the aspect ratio, and how to align src within dst. Returns the identity <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> if src is empty. If dst is empty, returns <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> set to: </p><pre class="fragment">| 0 0 0 |
| 0 0 0 |
| 0 0 1 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to map from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to map to </td></tr>
    <tr><td class="paramname">stf</td><td>one of: kFill_ScaleToFit, kStart_ScaleToFit, kCenter_ScaleToFit, kEnd_ScaleToFit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> mapping src to dst </dd></dl>

</div>
</div>
<a id="a85cd67b59f24ab307950b437c4669eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cd67b59f24ab307950b437c4669eae">&#9670;&nbsp;</a></span>MakeScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> MNN::CV::Matrix::MakeScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to scale by (sx, sy). Returned matrix is: </p><pre class="fragment">| sx  0  0 |
|  0 sy  0 |
|  0  0  1 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> with scale </dd></dl>

</div>
</div>
<a id="a3b05fbab55e352623bc6472a3a29b426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b05fbab55e352623bc6472a3a29b426">&#9670;&nbsp;</a></span>MakeScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> MNN::CV::Matrix::MakeScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to scale by (scale, scale). Returned matrix is: </p><pre class="fragment">| scale   0   0 |
|   0   scale 0 |
|   0     0   1 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>horizontal and vertical scale factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> with scale </dd></dl>

</div>
</div>
<a id="ad0a7c082d559ef73f93ec16e9644b590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a7c082d559ef73f93ec16e9644b590">&#9670;&nbsp;</a></span>MakeTrans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> MNN::CV::Matrix::MakeTrans </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to translate by (dx, dy). Returned matrix is: </p><pre class="fragment">| 1 0 dx |
| 0 1 dy |
| 0 0  1 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>horizontal translation </td></tr>
    <tr><td class="paramname">dy</td><td>vertical translation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> with translation </dd></dl>

</div>
</div>
<a id="a93dbff13c64c0ed0e9005b2609c550a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93dbff13c64c0ed0e9005b2609c550a1">&#9670;&nbsp;</a></span>mapPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::mapPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>dst</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps src <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> array of length count to dst <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> array of equal or greater length. <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> are mapped by multiplying each <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>where </p><pre class="fragment">for (i = 0; i &lt; count; ++i) {
    x = src[i].fX
    y = src[i].fY
}
</pre><p>each dst <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><p>src and dst may point to the same storage.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to transform </td></tr>
    <tr><td class="paramname">count</td><td>number of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7c756e36573cc6ef1c4f77c3088eaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c756e36573cc6ef1c4f77c3088eaee">&#9670;&nbsp;</a></span>mapPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::mapPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps pts <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> array of length count in place. <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> are mapped by multiplying each <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>where </p><pre class="fragment">for (i = 0; i &lt; count; ++i) {
    x = pts[i].fX
    y = pts[i].fY
}
</pre><p>each resulting pts <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>storage for mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> </td></tr>
    <tr><td class="paramname">count</td><td>number of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affd0b378ff8a6bd598db923cc8ccd2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd0b378ff8a6bd598db923cc8ccd2d1">&#9670;&nbsp;</a></span>mapRect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::mapRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets dst to bounds of src corners mapped by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. Returns true if mapped corners are dst corners.</p>
<p>Returned value is the same as calling <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aae4f4671dcd3eb69251b6b69b756c8eb">rectStaysRect()</a>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for bounds of mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if dst is equivalent to mapped src </dd></dl>

</div>
</div>
<a id="a2c1d97cacdb68559670ed7ebd5a02b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1d97cacdb68559670ed7ebd5a02b40">&#9670;&nbsp;</a></span>mapRect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::mapRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> *&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets rect to bounds of rect corners mapped by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. Returns true if mapped corners are computed rect corners.</p>
<p>Returned value is the same as calling <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aae4f4671dcd3eb69251b6b69b756c8eb">rectStaysRect()</a>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>rectangle to map, and storage for bounds of mapped corners </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if result is equivalent to mapped src </dd></dl>

</div>
</div>
<a id="a549c7d38b10404a4b61043b140dfebdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549c7d38b10404a4b61043b140dfebdc">&#9670;&nbsp;</a></span>mapRect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Matrix::mapRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns bounds of src corners mapped by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>rectangle to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>mapped bounds </dd></dl>

</div>
</div>
<a id="afdd5666970c26af2d84725856d4d7086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd5666970c26af2d84725856d4d7086">&#9670;&nbsp;</a></span>mapRectScaleTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::mapRectScaleTranslate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets dst to bounds of src corners mapped by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. If matrix contains elements other than scale or translate: asserts if SK_DEBUG is defined; otherwise, results are undefined.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for bounds of mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f97f8217503e8cb7ed70d2d54960a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f97f8217503e8cb7ed70d2d54960a54">&#9670;&nbsp;</a></span>mapXY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::mapXY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> (x, y) to result. <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> is mapped by multiplying by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>result is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-axis value of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to map </td></tr>
    <tr><td class="paramname">y</td><td>y-axis value of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to map </td></tr>
    <tr><td class="paramname">result</td><td>storage for mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d45157a305e7063765f534030163f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d45157a305e7063765f534030163f21">&#9670;&nbsp;</a></span>mapXY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> MNN::CV::Matrix::mapXY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> (x, y) multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>result is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-axis value of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to map </td></tr>
    <tr><td class="paramname">y</td><td>y-axis value of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> </dd></dl>

</div>
</div>
<a id="a6d75cd8885bc169ebbed0a3842d0a136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d75cd8885bc169ebbed0a3842d0a136">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Matrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one matrix value. Asserts if index is out of range and SK_DEBUG is defined.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>value corresponding to index </dd></dl>

</div>
</div>
<a id="ab70b003dcbc742777bb908511be6fd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70b003dcbc742777bb908511be6fd63">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float&amp; MNN::CV::Matrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns writable <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> value. Asserts if index is out of range and SK_DEBUG is defined. Clears internal cache anticipating that caller will change <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> value.</p>
<p>Next call to read <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> state may recompute cache; subsequent writes to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> value must be followed by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#af68596240a7b1dded463fd642f9a3362">dirtyMatrixTypeCache()</a>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>writable value corresponding to index </dd></dl>

</div>
</div>
<a id="adda26fa13f16bfc6dd310de0350eb1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda26fa13f16bfc6dd310de0350eb1ba">&#9670;&nbsp;</a></span>postConcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postConcat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> other multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of mapping by other after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |           | A B C |
Matrix = | M N O |,  other = | D E F |
         | P Q R |           | G H I |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                 | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
other * Matrix = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                 | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> on left side of multiply expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ebca3f0a5c0063e7c2e7841fafd5e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebca3f0a5c0063e7c2e7841fafd5e07">&#9670;&nbsp;</a></span>postIDiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::postIDiv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>divx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>divy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from scaling by (1/divx, 1/divy) about pivot point (px, py), multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Returns false if either divx or divy is zero.</p>
<p>Given: </p><pre class="fragment">         | J K L |                   | sx  0  0 |
Matrix = | M N O |,  I(divx, divy) = |  0 sy  0 |
         | P Q R |                   |  0  0  1 |
</pre><p>where </p><pre class="fragment">sx = 1 / divx
sy = 1 / divy
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                         | sx  0  0 | | J K L |   | sx*J sx*K sx*L |
I(divx, divy) * Matrix = |  0 sy  0 | | M N O | = | sy*M sy*N sy*O |
                         |  0  0  1 | | P Q R |   |    P    Q    R |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">divx</td><td>integer divisor for inverse scale in x </td></tr>
    <tr><td class="paramname">divy</td><td>integer divisor for inverse scale in y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true on successful scale </dd></dl>

</div>
</div>
<a id="a597b031b70c941779e251be9d74bbd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597b031b70c941779e251be9d74bbd22">&#9670;&nbsp;</a></span>postRotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postRotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from rotating by degrees about pivot point (px, py), multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of as rotating about a pivot point after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | J K L |                        | c -s dx |
Matrix = | M N O |,  R(degrees, px, py) = | s  c dy |
         | P Q R |                        | 0  0  1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
dx =  s * py + (1 - c) * px
dy = -s * px + (1 - c) * py
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                              |c -s dx| |J K L|   |cJ-sM+dx*P cK-sN+dx*Q cL-sO+dx+R|
R(degrees, px, py) * Matrix = |s  c dy| |M N O| = |sJ+cM+dy*P sK+cN+dy*Q sL+cO+dy*R|
                              |0  0  1| |P Q R|   |         P          Q          R|
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a267277c69b7ff90aa1149b8e4ec39945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267277c69b7ff90aa1149b8e4ec39945">&#9670;&nbsp;</a></span>postRotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postRotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from rotating by degrees about pivot point (0, 0), multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of as rotating about the origin after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | J K L |                        | c -s 0 |
Matrix = | M N O |,  R(degrees, px, py) = | s  c 0 |
         | P Q R |                        | 0  0 1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                              | c -s dx | | J K L |   | cJ-sM cK-sN cL-sO |
R(degrees, px, py) * Matrix = | s  c dy | | M N O | = | sJ+cM sK+cN sL+cO |
                              | 0  0  1 | | P Q R |   |     P     Q     R |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad176573dae007d41b6f649b480c2f154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad176573dae007d41b6f649b480c2f154">&#9670;&nbsp;</a></span>postScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from scaling by (sx, sy) about pivot point (px, py), multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of as scaling about a pivot point after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |                       | sx  0 dx |
Matrix = | M N O |,  S(sx, sy, px, py) = |  0 sy dy |
         | P Q R |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = px - sx * px
dy = py - sy * py
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                             | sx  0 dx | | J K L |   | sx*J+dx*P sx*K+dx*Q sx*L+dx+R |
S(sx, sy, px, py) * Matrix = |  0 sy dy | | M N O | = | sy*M+dy*P sy*N+dy*Q sy*O+dy*R |
                             |  0  0  1 | | P Q R |   |         P         Q         R |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a4f46eb00c55466465fe9674adfd44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4f46eb00c55466465fe9674adfd44b">&#9670;&nbsp;</a></span>postScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from scaling by (sx, sy) about pivot point (0, 0), multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of as scaling about the origin after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |               | sx  0  0 |
Matrix = | M N O |,  S(sx, sy) = |  0 sy  0 |
         | P Q R |               |  0  0  1 |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                     | sx  0  0 | | J K L |   | sx*J sx*K sx*L |
S(sx, sy) * Matrix = |  0 sy  0 | | M N O | = | sy*M sy*N sy*O |
                     |  0  0  1 | | P Q R |   |    P    Q    R |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d52a24c46117fd7f9500449d71c6443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d52a24c46117fd7f9500449d71c6443">&#9670;&nbsp;</a></span>postSkew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postSkew </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from skewing by (kx, ky) about pivot point (px, py), multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of as skewing about a pivot point after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |                       |  1 kx dx |
Matrix = | M N O |,  K(kx, ky, px, py) = | ky  1 dy |
         | P Q R |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = -kx * py
dy = -ky * px
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                             | 1 kx dx| |J K L|   |J+kx*M+dx*P K+kx*N+dx*Q L+kx*O+dx+R|
K(kx, ky, px, py) * Matrix = |ky  1 dy| |M N O| = |ky*J+M+dy*P ky*K+N+dy*Q ky*L+O+dy*R|
                             | 0  0  1| |P Q R|   |          P           Q           R|
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f7a662b6a506e25d7cc5c944191a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7a662b6a506e25d7cc5c944191a108">&#9670;&nbsp;</a></span>postSkew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postSkew </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from skewing by (kx, ky) about pivot point (0, 0), multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of as skewing about the origin after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |               |  1 kx 0 |
Matrix = | M N O |,  K(kx, ky) = | ky  1 0 |
         | P Q R |               |  0  0 1 |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                     |  1 kx 0 | | J K L |   | J+kx*M K+kx*N L+kx*O |
K(kx, ky) * Matrix = | ky  1 0 | | M N O | = | ky*J+M ky*K+N ky*L+O |
                     |  0  0 1 | | P Q R |   |      P      Q      R |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17b27c11657f122aa457c5d0fd8da777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b27c11657f122aa457c5d0fd8da777">&#9670;&nbsp;</a></span>postTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::postTranslate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from translation (dx, dy) multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. This can be thought of as moving the point to be mapped after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |               | 1 0 dx |
Matrix = | M N O |,  T(dx, dy) = | 0 1 dy |
         | P Q R |               | 0 0  1 |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                     | 1 0 dx | | J K L |   | J+dx*P K+dx*Q L+dx*R |
T(dx, dy) * Matrix = | 0 1 dy | | M N O | = | M+dy*P N+dy*Q O+dy*R |
                     | 0 0  1 | | P Q R |   |      P      Q      R |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>x-axis translation after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </td></tr>
    <tr><td class="paramname">dy</td><td>y-axis translation after applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af09590e014a86e9c3eb55160b09550e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09590e014a86e9c3eb55160b09550e2">&#9670;&nbsp;</a></span>preConcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preConcat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> other. This can be thought of mapping by other before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |          | J K L |
Matrix = | D E F |, other = | M N O |
         | G H I |          | P Q R |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                 | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
Matrix * other = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                 | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> on right side of multiply expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8d1dbd3d7038bf452d65cea53f86c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d1dbd3d7038bf452d65cea53f86c2a">&#9670;&nbsp;</a></span>preRotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preRotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from rotating by degrees about pivot point (px, py). This can be thought of as rotating about a pivot point before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | A B C |                        | c -s dx |
Matrix = | D E F |,  R(degrees, px, py) = | s  c dy |
         | G H I |                        | 0  0  1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
dx =  s * py + (1 - c) * px
dy = -s * px + (1 - c) * py
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                              | A B C | | c -s dx |   | Ac+Bs -As+Bc A*dx+B*dy+C |
Matrix * R(degrees, px, py) = | D E F | | s  c dy | = | Dc+Es -Ds+Ec D*dx+E*dy+F |
                              | G H I | | 0  0  1 |   | Gc+Hs -Gs+Hc G*dx+H*dy+I |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1a12516675c9d22b82ebe946f66d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1a12516675c9d22b82ebe946f66d08">&#9670;&nbsp;</a></span>preRotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preRotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from rotating by degrees about pivot point (0, 0). This can be thought of as rotating about the origin before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | A B C |                        | c -s 0 |
Matrix = | D E F |,  R(degrees, px, py) = | s  c 0 |
         | G H I |                        | 0  0 1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                              | A B C | | c -s 0 |   | Ac+Bs -As+Bc C |
Matrix * R(degrees, px, py) = | D E F | | s  c 0 | = | Dc+Es -Ds+Ec F |
                              | G H I | | 0  0 1 |   | Gc+Hs -Gs+Hc I |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f0c4dca4efbd6a9db3e8ded2719e625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c4dca4efbd6a9db3e8ded2719e625">&#9670;&nbsp;</a></span>preScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from scaling by (sx, sy) about pivot point (px, py). This can be thought of as scaling about a pivot point before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |                       | sx  0 dx |
Matrix = | D E F |,  S(sx, sy, px, py) = |  0 sy dy |
         | G H I |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = px - sx * px
dy = py - sy * py
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                             | A B C | | sx  0 dx |   | A*sx B*sy A*dx+B*dy+C |
Matrix * S(sx, sy, px, py) = | D E F | |  0 sy dy | = | D*sx E*sy D*dx+E*dy+F |
                             | G H I | |  0  0  1 |   | G*sx H*sy G*dx+H*dy+I |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab58e079f0d2779cdcc46ec8e0662e796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58e079f0d2779cdcc46ec8e0662e796">&#9670;&nbsp;</a></span>preScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from scaling by (sx, sy) about pivot point (0, 0). This can be thought of as scaling about the origin before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |               | sx  0  0 |
Matrix = | D E F |,  S(sx, sy) = |  0 sy  0 |
         | G H I |               |  0  0  1 |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                     | A B C | | sx  0  0 |   | A*sx B*sy C |
Matrix * S(sx, sy) = | D E F | |  0 sy  0 | = | D*sx E*sy F |
                     | G H I | |  0  0  1 |   | G*sx H*sy I |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fe9863cb0f149e97c57e0bd310a8091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe9863cb0f149e97c57e0bd310a8091">&#9670;&nbsp;</a></span>preservesAxisAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::preservesAxisAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> maps <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to another <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>. If true, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is identity, or scales, or rotates a multiple of 90 degrees, or mirrors on axes. In all cases, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> may also have translation. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> form is either: </p><pre class="fragment">| scale-x    0    translate-x |
|    0    scale-y translate-y |
|    0       0         1      |
</pre><p>or </p><pre class="fragment">|    0     rotate-x translate-x |
| rotate-y    0     translate-y |
|    0        0          1      |
</pre><p>for non-zero values of scale-x, scale-y, rotate-x, and rotate-y.</p>
<p>Also called <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#aae4f4671dcd3eb69251b6b69b756c8eb">rectStaysRect()</a>; use the one that provides better inline documentation.</p>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> maps one <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> into another </dd></dl>

</div>
</div>
<a id="a7ea95454829f1ceb48ac0cb42a253b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea95454829f1ceb48ac0cb42a253b11">&#9670;&nbsp;</a></span>preSkew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preSkew </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from skewing by (kx, ky) about pivot point (px, py). This can be thought of as skewing about a pivot point before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |                       |  1 kx dx |
Matrix = | D E F |,  K(kx, ky, px, py) = | ky  1 dy |
         | G H I |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = -kx * py
dy = -ky * px
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                             | A B C | |  1 kx dx |   | A+B*ky A*kx+B A*dx+B*dy+C |
Matrix * K(kx, ky, px, py) = | D E F | | ky  1 dy | = | D+E*ky D*kx+E D*dx+E*dy+F |
                             | G H I | |  0  0  1 |   | G+H*ky G*kx+H G*dx+H*dy+I |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f05afb8f62ddbfceb8638e67ff40b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f05afb8f62ddbfceb8638e67ff40b17">&#9670;&nbsp;</a></span>preSkew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preSkew </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from skewing by (kx, ky) about pivot point (0, 0). This can be thought of as skewing about the origin before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |               |  1 kx 0 |
Matrix = | D E F |,  K(kx, ky) = | ky  1 0 |
         | G H I |               |  0  0 1 |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                     | A B C | |  1 kx 0 |   | A+B*ky A*kx+B C |
Matrix * K(kx, ky) = | D E F | | ky  1 0 | = | D+E*ky D*kx+E F |
                     | G H I | |  0  0 1 |   | G+H*ky G*kx+H I |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedde66440e16fcf22fb5024dfafa4dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedde66440e16fcf22fb5024dfafa4dbf">&#9670;&nbsp;</a></span>preTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::preTranslate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> constructed from translation (dx, dy). This can be thought of as moving the point to be mapped before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |               | 1 0 dx |
Matrix = | D E F |,  T(dx, dy) = | 0 1 dy |
         | G H I |               | 0 0  1 |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">                     | A B C | | 1 0 dx |   | A B A*dx+B*dy+C |
Matrix * T(dx, dy) = | D E F | | 0 1 dy | = | D E D*dx+E*dy+F |
                     | G H I | | 0 0  1 |   | G H G*dx+H*dy+I |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>x-axis translation before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </td></tr>
    <tr><td class="paramname">dy</td><td>y-axis translation before applying <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae4f4671dcd3eb69251b6b69b756c8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4f4671dcd3eb69251b6b69b756c8eb">&#9670;&nbsp;</a></span>rectStaysRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::rectStaysRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> maps <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to another <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>. If true, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is identity, or scales, or rotates a multiple of 90 degrees, or mirrors on axes. In all cases, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> may also have translation. <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> form is either: </p><pre class="fragment">| scale-x    0    translate-x |
|    0    scale-y translate-y |
|    0       0         1      |
</pre><p>or </p><pre class="fragment">|    0     rotate-x translate-x |
| rotate-y    0     translate-y |
|    0        0          1      |
</pre><p>for non-zero values of scale-x, scale-y, rotate-x, and rotate-y.</p>
<p>Also called <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a0fe9863cb0f149e97c57e0bd310a8091">preservesAxisAlignment()</a>; use the one that provides better inline documentation.</p>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> maps one <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> into another </dd></dl>

</div>
</div>
<a id="a361d0f247ef268c716f3575c2c46c640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361d0f247ef268c716f3575c2c46c640">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to identity; which has no effect on mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>. Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><p>Also called <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ad46ca718c770bba11643c0ecc9a402fa">setIdentity()</a>; use the one that provides better inline documentation. </p>

</div>
</div>
<a id="a95657f702e16d797477c9aa24ac4a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95657f702e16d797477c9aa24ac4a0fd">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> value. Asserts if index is out of range and SK_DEBUG is defined. Safer than operator[]; internal cache is always maintained.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
    <tr><td class="paramname">value</td><td>scalar to store in <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb7b8bdb02f9cf2bbb4cc219cddb427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb7b8bdb02f9cf2bbb4cc219cddb427">&#9670;&nbsp;</a></span>set9()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::set9 </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>buffer</em>[9]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to nine scalar values in buffer, in member value ascending order: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2.</p>
<p>Sets matrix to: </p><pre class="fragment">| buffer[0] buffer[1] buffer[2] |
| buffer[3] buffer[4] buffer[5] |
| buffer[6] buffer[7] buffer[8] |
</pre><p>In the future, set9 followed by get9 may not return the same values. Since <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> maps non-homogeneous coordinates, scaling all nine values produces an equivalent transformation, possibly improving precision.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>nine scalar values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a163d8055f96099dfe15aeed62794b12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163d8055f96099dfe15aeed62794b12f">&#9670;&nbsp;</a></span>setAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setAffine </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>affine</em>[6]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to affine values, passed in column major order. Given affine, column, then row, as: </p><pre class="fragment">| scale-x  skew-x translate-x |
|  skew-y scale-y translate-y |
</pre><p><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> is set, row, then column, to: </p><pre class="fragment">| scale-x  skew-x translate-x |
|  skew-y scale-y translate-y |
|       0       0           1 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">affine</td><td>3x2 affine matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee028c3ec7bef9b08ec31e16ef1db01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee028c3ec7bef9b08ec31e16ef1db01b">&#9670;&nbsp;</a></span>SetAffineIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void MNN::CV::Matrix::SetAffineIdentity </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>affine</em>[6]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills affine with identity values in column major order. Sets affine to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
</pre><p>Affine 3x2 matrices in column major order are used by OpenGL and XPS.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">affine</td><td>storage for 3x2 affine matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c5adfb5b4236e756b95884de47c985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c5adfb5b4236e756b95884de47c985">&#9670;&nbsp;</a></span>setAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setAll </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>transX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>transY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>persp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>persp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>persp2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all values from parameters. Sets matrix to: </p><pre class="fragment">| scaleX  skewX transX |
|  skewY scaleY transY |
| persp0 persp1 persp2 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>horizontal scale factor to store </td></tr>
    <tr><td class="paramname">skewX</td><td>horizontal skew factor to store </td></tr>
    <tr><td class="paramname">transX</td><td>horizontal translation to store </td></tr>
    <tr><td class="paramname">skewY</td><td>vertical skew factor to store </td></tr>
    <tr><td class="paramname">scaleY</td><td>vertical scale factor to store </td></tr>
    <tr><td class="paramname">transY</td><td>vertical translation to store </td></tr>
    <tr><td class="paramname">persp0</td><td>input x-axis values perspective factor to store </td></tr>
    <tr><td class="paramname">persp1</td><td>input y-axis values perspective factor to store </td></tr>
    <tr><td class="paramname">persp2</td><td>perspective scale factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e76afc5160219aa3c331cd2263d622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e76afc5160219aa3c331cd2263d622c">&#9670;&nbsp;</a></span>setConcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setConcat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> a multiplied by <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> b. Either a or b may be this.</p>
<p>Given: </p><pre class="fragment">    | A B C |      | J K L |
a = | D E F |, b = | M N O |
    | G H I |      | P Q R |
</pre><p>sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">        | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
        | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> on left side of multiply expression </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> on right side of multiply expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad46ca718c770bba11643c0ecc9a402fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46ca718c770bba11643c0ecc9a402fa">&#9670;&nbsp;</a></span>setIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to identity; which has no effect on mapped <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>. Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><p>Also called <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a361d0f247ef268c716f3575c2c46c640">reset()</a>; use the one that provides better inline documentation. </p>

</div>
</div>
<a id="ac07d0f297600849a05dc3b175098121e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07d0f297600849a05dc3b175098121e">&#9670;&nbsp;</a></span>setPerspX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setPerspX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets input x-axis perspective factor, which causes <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a3f97f8217503e8cb7ed70d2d54960a54">mapXY()</a> to vary input x-axis values inversely proportional to input y-axis values.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>perspective factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a387100b9690549b671cf69a82cc134d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387100b9690549b671cf69a82cc134d1">&#9670;&nbsp;</a></span>setPerspY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setPerspY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets input y-axis perspective factor, which causes <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#a3f97f8217503e8cb7ed70d2d54960a54">mapXY()</a> to vary input y-axis values inversely proportional to input x-axis values.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>perspective factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcf1dae7c5be328fabc69baae8c710a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf1dae7c5be328fabc69baae8c710a9">&#9670;&nbsp;</a></span>setPolyToPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::setPolyToPoly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a>&#160;</td>
          <td class="paramname"><em>dst</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to map src to dst. count must be zero or greater, and four or less.</p>
<p>If count is zero, sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to identity and returns true. If count is one, sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to translate and returns true. If count is two or more, sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to map <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> if possible; returns false if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> cannot be constructed. If count is four, <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> may include perspective.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to map from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> to map to </td></tr>
    <tr><td class="paramname">count</td><td>number of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> in src and dst </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> was constructed successfully </dd></dl>

</div>
</div>
<a id="afe9ff946b4145e71f40205c9c23d63c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9ff946b4145e71f40205c9c23d63c7">&#9670;&nbsp;</a></span>setRectToRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Matrix::setRectToRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html#ac4c57512b9ff170b8c27141ac9dc2b16">ScaleToFit</a>&#160;</td>
          <td class="paramname"><em>stf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to scale and translate src <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to dst <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>. stf selects whether mapping completely fills dst or preserves the aspect ratio, and how to align src within dst. Returns false if src is empty, and sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to identity. Returns true if dst is empty, and sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to: </p><pre class="fragment">| 0 0 0 |
| 0 0 0 |
| 0 0 1 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to map from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to map to </td></tr>
    <tr><td class="paramname">stf</td><td>one of: kFill_ScaleToFit, kStart_ScaleToFit, kCenter_ScaleToFit, kEnd_ScaleToFit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> can represent <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> mapping </dd></dl>

</div>
</div>
<a id="afdbd6f23823704e5433fb701bce11717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbd6f23823704e5433fb701bce11717">&#9670;&nbsp;</a></span>setRotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setRotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to rotate by degrees about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682f1252147fc991ce77e1ca185bf667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682f1252147fc991ce77e1ca185bf667">&#9670;&nbsp;</a></span>setRotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setRotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to rotate by degrees about a pivot point at (0, 0). Positive degrees rotates clockwise.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32c757775b188138cf0b89f2cfd7f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c757775b188138cf0b89f2cfd7f2fd">&#9670;&nbsp;</a></span>setScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to scale by sx and sy, about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0147d1531b8456bc52a0a21b55b218f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0147d1531b8456bc52a0a21b55b218f">&#9670;&nbsp;</a></span>setScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to scale by sx and sy about at pivot point at (0, 0).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9900fc53c7e53893983ae6053ac2d98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9900fc53c7e53893983ae6053ac2d98f">&#9670;&nbsp;</a></span>setScaleTranslate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setScaleTranslate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> with scale and translate elements. </p><pre class="fragment">| sx  0 tx |
|  0 sy ty |
|  0  0  1 |
</pre><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor to store </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor to store </td></tr>
    <tr><td class="paramname">tx</td><td>horizontal translation to store </td></tr>
    <tr><td class="paramname">ty</td><td>vertical translation to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ef2a1e031dd5de7ff653038c401c1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef2a1e031dd5de7ff653038c401c1d4">&#9670;&nbsp;</a></span>setScaleX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setScaleX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets horizontal scale factor.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>horizontal scale factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a536b3ee8befe547496e47bef9422ca22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536b3ee8befe547496e47bef9422ca22">&#9670;&nbsp;</a></span>setScaleY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setScaleY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets vertical scale factor.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vertical scale factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d6ab1013e446d78b973a8bdfabff985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6ab1013e446d78b973a8bdfabff985">&#9670;&nbsp;</a></span>setSinCos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setSinCos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sinValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cosValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to rotate by sinValue and cosValue, about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<p>Vector (sinValue, cosValue) describes the angle of rotation relative to (0, 1). Vector length specifies scale.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinValue</td><td>rotation vector x-axis component </td></tr>
    <tr><td class="paramname">cosValue</td><td>rotation vector y-axis component </td></tr>
    <tr><td class="paramname">px</td><td>pivot x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63971f3c3729080655b490def47ef017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63971f3c3729080655b490def47ef017">&#9670;&nbsp;</a></span>setSinCos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setSinCos </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sinValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cosValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to rotate by sinValue and cosValue, about a pivot point at (0, 0).</p>
<p>Vector (sinValue, cosValue) describes the angle of rotation relative to (0, 1). Vector length specifies scale.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinValue</td><td>rotation vector x-axis component </td></tr>
    <tr><td class="paramname">cosValue</td><td>rotation vector y-axis component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a954006adc7c06d5c64c6a6092ca88de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954006adc7c06d5c64c6a6092ca88de7">&#9670;&nbsp;</a></span>setSkew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setSkew </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to skew by kx and ky, about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot x </td></tr>
    <tr><td class="paramname">py</td><td>pivot y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bbb54180ce88853fb112113dc6d539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbb54180ce88853fb112113dc6d539c">&#9670;&nbsp;</a></span>setSkew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setSkew </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to skew by kx and ky, about a pivot point at (0, 0).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e7c43a69da5564fade1134e245e5e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7c43a69da5564fade1134e245e5e65">&#9670;&nbsp;</a></span>setSkewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setSkewX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets horizontal skew factor.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>horizontal skew factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28974d70ccb159f0c79ebc46f73fdfde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28974d70ccb159f0c79ebc46f73fdfde">&#9670;&nbsp;</a></span>setSkewY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setSkewY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets vertical skew factor.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vertical skew factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64ddd5b5f07a3c7671502769cf95ecf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ddd5b5f07a3c7671502769cf95ecf8">&#9670;&nbsp;</a></span>setTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setTranslate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to translate by (dx, dy).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>horizontal translation </td></tr>
    <tr><td class="paramname">dy</td><td>vertical translation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafea25177ca15b3e66b796811ff12839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafea25177ca15b3e66b796811ff12839">&#9670;&nbsp;</a></span>setTranslateX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setTranslateX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets horizontal translation.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>horizontal translation to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af906c3d8207529707974d551d329ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af906c3d8207529707974d551d329ce39">&#9670;&nbsp;</a></span>setTranslateY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Matrix::setTranslateY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets vertical translation.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vertical translation to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">友元及相关函数文档</h2>
<a id="a9a2ab581fd780faf0c80cd3765fd3121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2ab581fd780faf0c80cd3765fd3121">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_m_n_n_define_8h.html#a692428e2a0af8ffb79376d223a0695ab">MNN_PUBLIC</a> bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a and b; returns true if a and b are not numerically equal. Returns false even if sign of zero values are different. Returns true if either <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> contains NaN, even if the other <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> also contains NaN.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> a and <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> b are numerically not equal </dd></dl>

</div>
</div>
<a id="a86b790569aa79e9472f9863751e0d133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b790569aa79e9472f9863751e0d133">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_m_n_n_define_8h.html#a692428e2a0af8ffb79376d223a0695ab">MNN_PUBLIC</a> bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a and b; returns true if a and b are numerically equal. Returns true even if sign of zero values are different. Returns false if either <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> contains NaN, even if the other <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> also contains NaN.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> a and <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> b are numerically equal </dd></dl>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="ae8e060cdf6868cdfdf0bae432aa17fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e060cdf6868cdfdf0bae432aa17fd5">&#9670;&nbsp;</a></span>kAScaleX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kAScaleX = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal scale factor </p>
<p>Affine arrays are in column major order to match the matrix used by PDF and XPS. </p>

</div>
</div>
<a id="a2df867ef1512a44a8539d46e0acad6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df867ef1512a44a8539d46e0acad6a9">&#9670;&nbsp;</a></span>kAScaleY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kAScaleY = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vertical scale factor </p>

</div>
</div>
<a id="a0eb9dedcccbc251c9a412cf71f4e0b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb9dedcccbc251c9a412cf71f4e0b3c">&#9670;&nbsp;</a></span>kASkewX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kASkewX = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal skew factor </p>

</div>
</div>
<a id="af9c71cf11a29bf7344357c28b4193545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c71cf11a29bf7344357c28b4193545">&#9670;&nbsp;</a></span>kASkewY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kASkewY = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vertical skew factor </p>

</div>
</div>
<a id="ad5ae3231629fc59390a63661edf1f447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ae3231629fc59390a63661edf1f447">&#9670;&nbsp;</a></span>kATransX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kATransX = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal translation </p>

</div>
</div>
<a id="a86ee756b37c955f7935cee8ea0e29081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ee756b37c955f7935cee8ea0e29081">&#9670;&nbsp;</a></span>kATransY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kATransY = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vertical translation </p>

</div>
</div>
<a id="ad89d5ae10e6a97e467805b7e67016071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89d5ae10e6a97e467805b7e67016071">&#9670;&nbsp;</a></span>kMPersp0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMPersp0 = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>input x perspective factor </p>

</div>
</div>
<a id="a5335529230f770344e12c15814a73040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5335529230f770344e12c15814a73040">&#9670;&nbsp;</a></span>kMPersp1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMPersp1 = 7</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>input y perspective factor </p>

</div>
</div>
<a id="aef5f38e0114da2fb099852078743d7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5f38e0114da2fb099852078743d7ad">&#9670;&nbsp;</a></span>kMPersp2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMPersp2 = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perspective bias </p>

</div>
</div>
<a id="a7de74100127ba6292318d4105e2448e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de74100127ba6292318d4105e2448e0">&#9670;&nbsp;</a></span>kMScaleX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMScaleX = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal scale factor </p>
<p><a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a> organizes its values in row order. These members correspond to each value in <a class="el" href="class_m_n_n_1_1_c_v_1_1_matrix.html">Matrix</a>. </p>

</div>
</div>
<a id="a0740678fdc865ecc7ffbe116fa4adb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0740678fdc865ecc7ffbe116fa4adb45">&#9670;&nbsp;</a></span>kMScaleY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMScaleY = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vertical scale factor </p>

</div>
</div>
<a id="a37665e4b858862fdc50366fac19ac7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37665e4b858862fdc50366fac19ac7b1">&#9670;&nbsp;</a></span>kMSkewX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMSkewX = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal skew factor </p>

</div>
</div>
<a id="a254d3c4f79dadfcde314f757430d46ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254d3c4f79dadfcde314f757430d46ae">&#9670;&nbsp;</a></span>kMSkewY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMSkewY = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vertical skew factor </p>

</div>
</div>
<a id="a202d2de9bc274df21d07e0d30fb7f7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202d2de9bc274df21d07e0d30fb7f7a4">&#9670;&nbsp;</a></span>kMTransX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMTransX = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal translation </p>

</div>
</div>
<a id="a92341274274d04e3fd668843157ed393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92341274274d04e3fd668843157ed393">&#9670;&nbsp;</a></span>kMTransY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int MNN::CV::Matrix::kMTransY = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vertical translation </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>include/<a class="el" href="_matrix_8h_source.html">Matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
