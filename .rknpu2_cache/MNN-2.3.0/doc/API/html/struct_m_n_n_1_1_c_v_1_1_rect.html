<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MNN: MNN::CV::Rect结构体 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MNN
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','搜索');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_m_n_n.html">MNN</a></li><li class="navelem"><a class="el" href="namespace_m_n_n_1_1_c_v.html">CV</a></li><li class="navelem"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pub-attribs">Public 属性</a> &#124;
<a href="struct_m_n_n_1_1_c_v_1_1_rect-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">MNN::CV::Rect结构体 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_rect_8h_source.html">Rect.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:ad29c16121be6701ae8bddfc19b8e0af8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ad29c16121be6701ae8bddfc19b8e0af8">isEmpty</a> () const</td></tr>
<tr class="separator:ad29c16121be6701ae8bddfc19b8e0af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0571b2879b52e0c733428b47c3880e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ac0571b2879b52e0c733428b47c3880e2">isSorted</a> () const</td></tr>
<tr class="separator:ac0571b2879b52e0c733428b47c3880e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58f6d07f1c5cb1622f3878ee9d3e8f2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#af58f6d07f1c5cb1622f3878ee9d3e8f2">x</a> () const</td></tr>
<tr class="separator:af58f6d07f1c5cb1622f3878ee9d3e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a01972b232acc3d8a90719e548d919e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a1a01972b232acc3d8a90719e548d919e">y</a> () const</td></tr>
<tr class="separator:a1a01972b232acc3d8a90719e548d919e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa160cb2eb1fc6135ccc3877d8c87b510"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa160cb2eb1fc6135ccc3877d8c87b510">left</a> () const</td></tr>
<tr class="separator:aa160cb2eb1fc6135ccc3877d8c87b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01177c3c1c082e37bc19527e7c2b663f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a01177c3c1c082e37bc19527e7c2b663f">top</a> () const</td></tr>
<tr class="separator:a01177c3c1c082e37bc19527e7c2b663f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c059082d158da6e4e4bf1b8a3201041"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a9c059082d158da6e4e4bf1b8a3201041">right</a> () const</td></tr>
<tr class="separator:a9c059082d158da6e4e4bf1b8a3201041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf1130e452a00fe072058829c8c8bcd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aadf1130e452a00fe072058829c8c8bcd">bottom</a> () const</td></tr>
<tr class="separator:aadf1130e452a00fe072058829c8c8bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c8b45618876fd833da41c5b3be6954"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width</a> () const</td></tr>
<tr class="separator:a95c8b45618876fd833da41c5b3be6954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fc5d37b129f7f1f29a1e42f6539ad3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height</a> () const</td></tr>
<tr class="separator:aa7fc5d37b129f7f1f29a1e42f6539ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4c5536bc1d9efff77d41da5645e29d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a3a4c5536bc1d9efff77d41da5645e29d">centerX</a> () const</td></tr>
<tr class="separator:a3a4c5536bc1d9efff77d41da5645e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fa5256843c96283961017ae007efdc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a78fa5256843c96283961017ae007efdc">centerY</a> () const</td></tr>
<tr class="separator:a78fa5256843c96283961017ae007efdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3840d59c7e57fea47cf22cb380443c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a2b3840d59c7e57fea47cf22cb380443c">setEmpty</a> ()</td></tr>
<tr class="separator:a2b3840d59c7e57fea47cf22cb380443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af779724236a4e6f70a1c83e64fb34f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#af779724236a4e6f70a1c83e64fb34f62">set</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa160cb2eb1fc6135ccc3877d8c87b510">left</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a01177c3c1c082e37bc19527e7c2b663f">top</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a9c059082d158da6e4e4bf1b8a3201041">right</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aadf1130e452a00fe072058829c8c8bcd">bottom</a>)</td></tr>
<tr class="separator:af779724236a4e6f70a1c83e64fb34f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532c1b7e17793f40cf2dccde039d7930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a532c1b7e17793f40cf2dccde039d7930">setLTRB</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa160cb2eb1fc6135ccc3877d8c87b510">left</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a01177c3c1c082e37bc19527e7c2b663f">top</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a9c059082d158da6e4e4bf1b8a3201041">right</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aadf1130e452a00fe072058829c8c8bcd">bottom</a>)</td></tr>
<tr class="separator:a532c1b7e17793f40cf2dccde039d7930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e83b53b1d3474fedcab0b52660acd8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a6e83b53b1d3474fedcab0b52660acd8e">iset</a> (int <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa160cb2eb1fc6135ccc3877d8c87b510">left</a>, int <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a01177c3c1c082e37bc19527e7c2b663f">top</a>, int <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a9c059082d158da6e4e4bf1b8a3201041">right</a>, int <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aadf1130e452a00fe072058829c8c8bcd">bottom</a>)</td></tr>
<tr class="separator:a6e83b53b1d3474fedcab0b52660acd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab144e0eca8fa19ae44d109ae4fe0d94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aab144e0eca8fa19ae44d109ae4fe0d94">isetWH</a> (int <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width</a>, int <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height</a>)</td></tr>
<tr class="separator:aab144e0eca8fa19ae44d109ae4fe0d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aece72c48ea4638f1a21f0a9aa4fed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a6aece72c48ea4638f1a21f0a9aa4fed6">setXYWH</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#af58f6d07f1c5cb1622f3878ee9d3e8f2">x</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a1a01972b232acc3d8a90719e548d919e">y</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height</a>)</td></tr>
<tr class="separator:a6aece72c48ea4638f1a21f0a9aa4fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a00e95e1c00e82ac601a21ac6694463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a3a00e95e1c00e82ac601a21ac6694463">setWH</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height</a>)</td></tr>
<tr class="separator:a3a00e95e1c00e82ac601a21ac6694463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72efee72527d4c6ae1a9475f629c6ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a72efee72527d4c6ae1a9475f629c6ac0">makeOffset</a> (float dx, float dy) const</td></tr>
<tr class="separator:a72efee72527d4c6ae1a9475f629c6ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5d14a019fd282f7e05cef663554fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a3b5d14a019fd282f7e05cef663554fbc">makeInset</a> (float dx, float dy) const</td></tr>
<tr class="separator:a3b5d14a019fd282f7e05cef663554fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef81d24e7865ec630cc6c19ffadecc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#adef81d24e7865ec630cc6c19ffadecc9">makeOutset</a> (float dx, float dy) const</td></tr>
<tr class="separator:adef81d24e7865ec630cc6c19ffadecc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a1f1f6e70c37968942769543a49e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a91a1f1f6e70c37968942769543a49e2d">offset</a> (float dx, float dy)</td></tr>
<tr class="separator:a91a1f1f6e70c37968942769543a49e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa514595203fd1b7523507c6f97646781"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa514595203fd1b7523507c6f97646781">offsetTo</a> (float newX, float newY)</td></tr>
<tr class="separator:aa514595203fd1b7523507c6f97646781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec8cf044453b6b618d993430ec08973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#acec8cf044453b6b618d993430ec08973">inset</a> (float dx, float dy)</td></tr>
<tr class="separator:acec8cf044453b6b618d993430ec08973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab616f3320e1872a2f9808f0e8d5a86c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ab616f3320e1872a2f9808f0e8d5a86c8">outset</a> (float dx, float dy)</td></tr>
<tr class="separator:ab616f3320e1872a2f9808f0e8d5a86c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5e73248850d1d603c03bd5a1e9f0b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aac5e73248850d1d603c03bd5a1e9f0b3">intersect</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;r)</td></tr>
<tr class="separator:aac5e73248850d1d603c03bd5a1e9f0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186c6a231ddf614a003b06020519199d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a186c6a231ddf614a003b06020519199d">intersect</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa160cb2eb1fc6135ccc3877d8c87b510">left</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a01177c3c1c082e37bc19527e7c2b663f">top</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a9c059082d158da6e4e4bf1b8a3201041">right</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aadf1130e452a00fe072058829c8c8bcd">bottom</a>)</td></tr>
<tr class="separator:a186c6a231ddf614a003b06020519199d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac3edc15f7faa5fa0afadf54cd380e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ae5ac3edc15f7faa5fa0afadf54cd380e">intersect</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;a, const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;b)</td></tr>
<tr class="separator:ae5ac3edc15f7faa5fa0afadf54cd380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3545f0e12bff349c1071f0a0b655fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a8b3545f0e12bff349c1071f0a0b655fb">intersects</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa160cb2eb1fc6135ccc3877d8c87b510">left</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a01177c3c1c082e37bc19527e7c2b663f">top</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a9c059082d158da6e4e4bf1b8a3201041">right</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aadf1130e452a00fe072058829c8c8bcd">bottom</a>) const</td></tr>
<tr class="separator:a8b3545f0e12bff349c1071f0a0b655fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1751c3784411427f17270f3c68e0093e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a1751c3784411427f17270f3c68e0093e">intersects</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;r) const</td></tr>
<tr class="separator:a1751c3784411427f17270f3c68e0093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6f029c6c01bdcf344594722e5eed5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a2a6f029c6c01bdcf344594722e5eed5f">join</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa160cb2eb1fc6135ccc3877d8c87b510">left</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a01177c3c1c082e37bc19527e7c2b663f">top</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a9c059082d158da6e4e4bf1b8a3201041">right</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aadf1130e452a00fe072058829c8c8bcd">bottom</a>)</td></tr>
<tr class="separator:a2a6f029c6c01bdcf344594722e5eed5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f779242e85a6a56b230c15fb10e88d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ae7f779242e85a6a56b230c15fb10e88d">join</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;r)</td></tr>
<tr class="separator:ae7f779242e85a6a56b230c15fb10e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc003e093d8ccb40326cd4bb45f80c50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#acc003e093d8ccb40326cd4bb45f80c50">joinNonEmptyArg</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;r)</td></tr>
<tr class="separator:acc003e093d8ccb40326cd4bb45f80c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8118759f998e6e692bddeb4f238c6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a8b8118759f998e6e692bddeb4f238c6d">joinPossiblyEmptyRect</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;r)</td></tr>
<tr class="separator:a8b8118759f998e6e692bddeb4f238c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c7f529bcd4fcf4ed549ae758e0185e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a40c7f529bcd4fcf4ed549ae758e0185e">contains</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#af58f6d07f1c5cb1622f3878ee9d3e8f2">x</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a1a01972b232acc3d8a90719e548d919e">y</a>) const</td></tr>
<tr class="separator:a40c7f529bcd4fcf4ed549ae758e0185e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f11ca8d611000b282c38daa3dc4cab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort</a> ()</td></tr>
<tr class="separator:a0f11ca8d611000b282c38daa3dc4cab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380de5592d15cce1ccdcd65d6f6233f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a380de5592d15cce1ccdcd65d6f6233f0">makeSorted</a> () const</td></tr>
<tr class="separator:a380de5592d15cce1ccdcd65d6f6233f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5a5bc3392e58b7e9fb00da124a861"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ac1b5a5bc3392e58b7e9fb00da124a861">asScalars</a> () const</td></tr>
<tr class="separator:ac1b5a5bc3392e58b7e9fb00da124a861"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:af67332903693248a739ca9f70cb0b5d4"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#af67332903693248a739ca9f70cb0b5d4">MakeEmpty</a> ()</td></tr>
<tr class="separator:af67332903693248a739ca9f70cb0b5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ddfe89f2ec3ac3270615a3d0ff2394"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a02ddfe89f2ec3ac3270615a3d0ff2394">MakeWH</a> (float w, float h)</td></tr>
<tr class="separator:a02ddfe89f2ec3ac3270615a3d0ff2394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada503f876d48a20715410a6d693eb588"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ada503f876d48a20715410a6d693eb588">MakeIWH</a> (int w, int h)</td></tr>
<tr class="separator:ada503f876d48a20715410a6d693eb588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383b4f2f97e8a4cb7e78388f599cc9c4"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a383b4f2f97e8a4cb7e78388f599cc9c4">MakeLTRB</a> (float l, float t, float r, float b)</td></tr>
<tr class="separator:a383b4f2f97e8a4cb7e78388f599cc9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c940fce58ec7c6bdde197022e549da"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a84c940fce58ec7c6bdde197022e549da">MakeXYWH</a> (float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#af58f6d07f1c5cb1622f3878ee9d3e8f2">x</a>, float <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a1a01972b232acc3d8a90719e548d919e">y</a>, float w, float h)</td></tr>
<tr class="separator:a84c940fce58ec7c6bdde197022e549da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344296c6a536e3c5734e6f4ff431b33a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a344296c6a536e3c5734e6f4ff431b33a">Intersects</a> (const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;a, const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;b)</td></tr>
<tr class="separator:a344296c6a536e3c5734e6f4ff431b33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public 属性</h2></td></tr>
<tr class="memitem:a64258783d446020019f2062282afdcdd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a64258783d446020019f2062282afdcdd">fLeft</a></td></tr>
<tr class="memdesc:a64258783d446020019f2062282afdcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">smaller x-axis bounds  <a href="#a64258783d446020019f2062282afdcdd">更多...</a><br /></td></tr>
<tr class="separator:a64258783d446020019f2062282afdcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208f7896ff9557d5cef93add6696d15f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a208f7896ff9557d5cef93add6696d15f">fTop</a></td></tr>
<tr class="memdesc:a208f7896ff9557d5cef93add6696d15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">smaller y-axis bounds  <a href="#a208f7896ff9557d5cef93add6696d15f">更多...</a><br /></td></tr>
<tr class="separator:a208f7896ff9557d5cef93add6696d15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0359c6cdfd938d0b8d0396315d996904"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0359c6cdfd938d0b8d0396315d996904">fRight</a></td></tr>
<tr class="memdesc:a0359c6cdfd938d0b8d0396315d996904"><td class="mdescLeft">&#160;</td><td class="mdescRight">larger x-axis bounds  <a href="#a0359c6cdfd938d0b8d0396315d996904">更多...</a><br /></td></tr>
<tr class="separator:a0359c6cdfd938d0b8d0396315d996904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405b1f172d1edcd94b5bd9958a1bf2de"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a405b1f172d1edcd94b5bd9958a1bf2de">fBottom</a></td></tr>
<tr class="memdesc:a405b1f172d1edcd94b5bd9958a1bf2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">larger y-axis bounds  <a href="#a405b1f172d1edcd94b5bd9958a1bf2de">更多...</a><br /></td></tr>
<tr class="separator:a405b1f172d1edcd94b5bd9958a1bf2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> holds four float coordinates describing the upper and lower bounds of a rectangle. <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> may be created from outer bounds or from position, width, and height. <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> describes an area; if its right is less than or equal to its left, or if its bottom is less than or equal to its top, it is considered empty. </p>
</div><h2 class="groupheader">成员函数说明</h2>
<a id="ac1b5a5bc3392e58b7e9fb00da124a861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b5a5bc3392e58b7e9fb00da124a861">&#9670;&nbsp;</a></span>asScalars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float* MNN::CV::Rect::asScalars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pointer to first scalar in <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, to treat it as an array with four entries.</p>
<dl class="section return"><dt>返回</dt><dd>pointer to fLeft </dd></dl>

</div>
</div>
<a id="aadf1130e452a00fe072058829c8c8bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf1130e452a00fe072058829c8c8bcd">&#9670;&nbsp;</a></span>bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns bottom edge of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, if sorted. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ad29c16121be6701ae8bddfc19b8e0af8">isEmpty()</a> to see if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> may be invalid, and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>返回</dt><dd>fBottom </dd></dl>

</div>
</div>
<a id="a3a4c5536bc1d9efff77d41da5645e29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4c5536bc1d9efff77d41da5645e29d">&#9670;&nbsp;</a></span>centerX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::centerX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns average of left edge and right edge. Result does not change if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is sorted. Result may overflow to infinity if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is far from the origin.</p>
<dl class="section return"><dt>返回</dt><dd>midpoint in x </dd></dl>

</div>
</div>
<a id="a78fa5256843c96283961017ae007efdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fa5256843c96283961017ae007efdc">&#9670;&nbsp;</a></span>centerY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::centerY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns average of top edge and bottom edge. Result does not change if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is sorted.</p>
<dl class="section return"><dt>返回</dt><dd>midpoint in y </dd></dl>

</div>
</div>
<a id="a40c7f529bcd4fcf4ed549ae758e0185e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c7f529bcd4fcf4ed549ae758e0185e">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::contains </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if: fLeft &lt;= x &lt; fRight &amp;&amp; fTop &lt;= y &lt; fBottom. Returns false if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>test <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> x-coordinate </td></tr>
    <tr><td class="paramname">y</td><td>test <a class="el" href="struct_m_n_n_1_1_c_v_1_1_point.html">Point</a> y-coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if (x, y) is inside <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </dd></dl>

</div>
</div>
<a id="aa7fc5d37b129f7f1f29a1e42f6539ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fc5d37b129f7f1f29a1e42f6539ad3">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the y-axis. This does not check if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is sorted, or if result fits in 32-bit float; result may be negative or infinity.</p>
<dl class="section return"><dt>返回</dt><dd>fBottom minus fTop </dd></dl>

</div>
</div>
<a id="acec8cf044453b6b618d993430ec08973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec8cf044453b6b618d993430ec08973">&#9670;&nbsp;</a></span>inset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::inset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> by (dx, dy).</p>
<p>If dx is positive, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> narrower. If dx is negative, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> wider. If dy is positive, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> shorter. If dy is negative, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> taller.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>added to fLeft and subtracted from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>added to fTop and subtracted from fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac5e73248850d1d603c03bd5a1e9f0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5e73248850d1d603c03bd5a1e9f0b3">&#9670;&nbsp;</a></span>intersect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> intersects r, and sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersection. Returns false if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> does not intersect r, and leaves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> unchanged.</p>
<p>Returns false if either r or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty, leaving <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> unchanged.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>limit of result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if r and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> have area in common </dd></dl>

</div>
</div>
<a id="a186c6a231ddf614a003b06020519199d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186c6a231ddf614a003b06020519199d">&#9670;&nbsp;</a></span>intersect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::intersect </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect from (left, top, right, bottom). Does not sort construction.</p>
<p>Returns true if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> intersects construction, and sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersection. Returns false if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> does not intersect construction, and leaves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> unchanged.</p>
<p>Returns false if either construction or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty, leaving <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> unchanged.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>x-axis minimum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">top</td><td>y-axis minimum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">right</td><td>x-axis maximum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">bottom</td><td>y-axis maximum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if construction and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> have area in common </dd></dl>

</div>
</div>
<a id="ae5ac3edc15f7faa5fa0afadf54cd380e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ac3edc15f7faa5fa0afadf54cd380e">&#9670;&nbsp;</a></span>intersect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a intersects b, and sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersection. Returns false if a does not intersect b, and leaves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> unchanged.</p>
<p>Returns false if either a or b is empty, leaving <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> unchanged.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if a and b have area in common </dd></dl>

</div>
</div>
<a id="a8b3545f0e12bff349c1071f0a0b655fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3545f0e12bff349c1071f0a0b655fb">&#9670;&nbsp;</a></span>intersects() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::intersects </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect from (left, top, right, bottom). Does not sort construction.</p>
<p>Returns true if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> intersects construction. Returns false if either construction or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty, or do not intersect.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>x-axis minimum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">top</td><td>y-axis minimum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">right</td><td>x-axis maximum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">bottom</td><td>y-axis maximum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if construction and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> have area in common </dd></dl>

</div>
</div>
<a id="a1751c3784411427f17270f3c68e0093e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1751c3784411427f17270f3c68e0093e">&#9670;&nbsp;</a></span>intersects() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> intersects r. Returns false if either r or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty, or do not intersect.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if r and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> have area in common </dd></dl>

</div>
</div>
<a id="a344296c6a536e3c5734e6f4ff431b33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344296c6a536e3c5734e6f4ff431b33a">&#9670;&nbsp;</a></span>Intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool MNN::CV::Rect::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a intersects b. Returns false if either a or b is empty, or do not intersect.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if a and b have area in common </dd></dl>

</div>
</div>
<a id="ad29c16121be6701ae8bddfc19b8e0af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29c16121be6701ae8bddfc19b8e0af8">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if fLeft is equal to or greater than fRight, or if fTop is equal to or greater than fBottom. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse rectangles with negative <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width()</a> or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height()</a>.</p>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width()</a> or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height()</a> are zero or negative </dd></dl>

</div>
</div>
<a id="a6e83b53b1d3474fedcab0b52660acd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e83b53b1d3474fedcab0b52660acd8e">&#9670;&nbsp;</a></span>iset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::iset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to (left, top, right, bottom). All parameters are promoted from integer to scalar. left and right are not sorted; left is not necessarily less than right. top and bottom are not sorted; top is not necessarily less than bottom.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>promoted to float and stored in fLeft </td></tr>
    <tr><td class="paramname">top</td><td>promoted to float and stored in fTop </td></tr>
    <tr><td class="paramname">right</td><td>promoted to float and stored in fRight </td></tr>
    <tr><td class="paramname">bottom</td><td>promoted to float and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab144e0eca8fa19ae44d109ae4fe0d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab144e0eca8fa19ae44d109ae4fe0d94">&#9670;&nbsp;</a></span>isetWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::isetWH </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to (0, 0, width, height). width and height may be zero or negative. width and height are promoted from integer to float, large values may lose precision.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>promoted to float and stored in fRight </td></tr>
    <tr><td class="paramname">height</td><td>promoted to float and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0571b2879b52e0c733428b47c3880e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0571b2879b52e0c733428b47c3880e2">&#9670;&nbsp;</a></span>isSorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MNN::CV::Rect::isSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if fLeft is equal to or less than fRight, or if fTop is equal to or less than fBottom. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse rectangles with negative <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width()</a> or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height()</a>.</p>
<dl class="section return"><dt>返回</dt><dd>true if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width()</a> or <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height()</a> are zero or positive </dd></dl>

</div>
</div>
<a id="a2a6f029c6c01bdcf344594722e5eed5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6f029c6c01bdcf344594722e5eed5f">&#9670;&nbsp;</a></span>join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::join </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to intersect from (left, top, right, bottom). Does not sort construction.</p>
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to the union of itself and the construction.</p>
<p>Has no effect if construction is empty. Otherwise, if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty, sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to construction.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>x-axis minimum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">top</td><td>y-axis minimum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">right</td><td>x-axis maximum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">bottom</td><td>y-axis maximum of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7f779242e85a6a56b230c15fb10e88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f779242e85a6a56b230c15fb10e88d">&#9670;&nbsp;</a></span>join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to the union of itself and r.</p>
<p>Has no effect if r is empty. Otherwise, if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty, sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to r.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>expansion <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc003e093d8ccb40326cd4bb45f80c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc003e093d8ccb40326cd4bb45f80c50">&#9670;&nbsp;</a></span>joinNonEmptyArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::joinNonEmptyArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to the union of itself and r.</p>
<p>Asserts if r is empty and SK_DEBUG is defined. If <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is empty, sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to r.</p>
<p>May produce incorrect results if r is empty.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>expansion <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b8118759f998e6e692bddeb4f238c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8118759f998e6e692bddeb4f238c6d">&#9670;&nbsp;</a></span>joinPossiblyEmptyRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::joinPossiblyEmptyRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to the union of itself and the construction.</p>
<p>May produce incorrect results if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> or r is empty.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>expansion <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa160cb2eb1fc6135ccc3877d8c87b510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa160cb2eb1fc6135ccc3877d8c87b510">&#9670;&nbsp;</a></span>left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns left edge of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, if sorted. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ac0571b2879b52e0c733428b47c3880e2">isSorted()</a> to see if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is valid. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>返回</dt><dd>fLeft </dd></dl>

</div>
</div>
<a id="af67332903693248a739ca9f70cb0b5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67332903693248a739ca9f70cb0b5d4">&#9670;&nbsp;</a></span>MakeEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::MakeEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> set to (0, 0, 0, 0). Many other rectangles are empty; if left is equal to or greater than right, or if top is equal to or greater than bottom. Setting all members to zero is a convenience, but does not designate a special empty rectangle.</p>
<dl class="section return"><dt>返回</dt><dd>bounds (0, 0, 0, 0) </dd></dl>

</div>
</div>
<a id="a3b5d14a019fd282f7e05cef663554fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5d14a019fd282f7e05cef663554fbc">&#9670;&nbsp;</a></span>makeInset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::makeInset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, inset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is wider. If dx is positive, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is narrower. If dy is negative, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is taller. If dy is positive, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is shorter.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>added to fLeft and subtracted from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>added to fTop and subtracted from fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> inset symmetrically left and right, top and bottom </dd></dl>

</div>
</div>
<a id="ada503f876d48a20715410a6d693eb588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada503f876d48a20715410a6d693eb588">&#9670;&nbsp;</a></span>MakeIWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::MakeIWH </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> set to integer values (0, 0, w, h). Does not validate input; w or h may be negative.</p>
<p>Use to avoid a compiler warning that input may lose precision when stored. Use SkIRect for an exact integer rectangle.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>integer width of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">h</td><td>integer height of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bounds (0, 0, w, h) </dd></dl>

</div>
</div>
<a id="a383b4f2f97e8a4cb7e78388f599cc9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383b4f2f97e8a4cb7e78388f599cc9c4">&#9670;&nbsp;</a></span>MakeLTRB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::MakeLTRB </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> set to (l, t, r, b). Does not sort input; <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> may result in fLeft greater than fRight, or fTop greater than fBottom.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>float stored in fLeft </td></tr>
    <tr><td class="paramname">t</td><td>float stored in fTop </td></tr>
    <tr><td class="paramname">r</td><td>float stored in fRight </td></tr>
    <tr><td class="paramname">b</td><td>float stored in fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bounds (l, t, r, b) </dd></dl>

</div>
</div>
<a id="a72efee72527d4c6ae1a9475f629c6ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72efee72527d4c6ae1a9475f629c6ac0">&#9670;&nbsp;</a></span>makeOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::makeOffset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> offset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is moved to the left. If dx is positive, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is moved to the right. If dy is negative, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is moved upward. If dy is positive, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is moved downward.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>added to fLeft and fRight </td></tr>
    <tr><td class="paramname">dy</td><td>added to fTop and fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> offset on axes, with original width and height </dd></dl>

</div>
</div>
<a id="adef81d24e7865ec630cc6c19ffadecc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef81d24e7865ec630cc6c19ffadecc9">&#9670;&nbsp;</a></span>makeOutset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::makeOutset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, outset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is narrower. If dx is positive, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is wider. If dy is negative, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is shorter. If dy is positive, <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> returned is taller.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>subtracted to fLeft and added from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>subtracted to fTop and added from fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> outset symmetrically left and right, top and bottom </dd></dl>

</div>
</div>
<a id="a380de5592d15cce1ccdcd65d6f6233f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380de5592d15cce1ccdcd65d6f6233f0">&#9670;&nbsp;</a></span>makeSorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::makeSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> with fLeft and fRight swapped if fLeft is greater than fRight; and with fTop and fBottom swapped if fTop is greater than fBottom. Result may be empty; and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width()</a> and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height()</a> will be zero or positive.</p>
<dl class="section return"><dt>返回</dt><dd>sorted <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </dd></dl>

</div>
</div>
<a id="a02ddfe89f2ec3ac3270615a3d0ff2394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ddfe89f2ec3ac3270615a3d0ff2394">&#9670;&nbsp;</a></span>MakeWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::MakeWH </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> set to float values (0, 0, w, h). Does not validate input; w or h may be negative.</p>
<p>Passing integer values may generate a compiler warning since <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> cannot represent 32-bit integers exactly. Use SkIRect for an exact integer rectangle.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>float width of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
    <tr><td class="paramname">h</td><td>float height of constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bounds (0, 0, w, h) </dd></dl>

</div>
</div>
<a id="a84c940fce58ec7c6bdde197022e549da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c940fce58ec7c6bdde197022e549da">&#9670;&nbsp;</a></span>MakeXYWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> MNN::CV::Rect::MakeXYWH </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> set to (x, y, x + w, y + h). Does not validate input; w or h may be negative.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">y</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">w</td><td>added to x and stored in fRight </td></tr>
    <tr><td class="paramname">h</td><td>added to y and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bounds at (x, y) with width w and height h </dd></dl>

</div>
</div>
<a id="a91a1f1f6e70c37968942769543a49e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a1f1f6e70c37968942769543a49e2d">&#9670;&nbsp;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::offset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> by adding dx to fLeft, fRight; and by adding dy to fTop, fBottom.</p>
<p>If dx is negative, moves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to the left. If dx is positive, moves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to the right. If dy is negative, moves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> upward. If dy is positive, moves <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> downward.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to fLeft and fRight </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to fTop and fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa514595203fd1b7523507c6f97646781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa514595203fd1b7523507c6f97646781">&#9670;&nbsp;</a></span>offsetTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::offsetTo </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> so that fLeft equals newX, and fTop equals newY. width and height are unchanged.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">newX</td><td>stored in fLeft, preserving <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width()</a> </td></tr>
    <tr><td class="paramname">newY</td><td>stored in fTop, preserving <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab616f3320e1872a2f9808f0e8d5a86c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab616f3320e1872a2f9808f0e8d5a86c8">&#9670;&nbsp;</a></span>outset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::outset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outsets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> by (dx, dy).</p>
<p>If dx is positive, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> wider. If dx is negative, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> narrower. If dy is positive, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> taller. If dy is negative, makes <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> shorter.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>subtracted to fLeft and added from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>subtracted to fTop and added from fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c059082d158da6e4e4bf1b8a3201041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c059082d158da6e4e4bf1b8a3201041">&#9670;&nbsp;</a></span>right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns right edge of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, if sorted. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ac0571b2879b52e0c733428b47c3880e2">isSorted()</a> to see if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is valid. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>返回</dt><dd>fRight </dd></dl>

</div>
</div>
<a id="af779724236a4e6f70a1c83e64fb34f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af779724236a4e6f70a1c83e64fb34f62">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::set </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to (left, top, right, bottom). left and right are not sorted; left is not necessarily less than right. top and bottom are not sorted; top is not necessarily less than bottom.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">top</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">right</td><td>stored in fRight </td></tr>
    <tr><td class="paramname">bottom</td><td>stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b3840d59c7e57fea47cf22cb380443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3840d59c7e57fea47cf22cb380443c">&#9670;&nbsp;</a></span>setEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::setEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to (0, 0, 0, 0).</p>
<p>Many other rectangles are empty; if left is equal to or greater than right, or if top is equal to or greater than bottom. Setting all members to zero is a convenience, but does not designate a special empty rectangle. </p>

</div>
</div>
<a id="a532c1b7e17793f40cf2dccde039d7930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532c1b7e17793f40cf2dccde039d7930">&#9670;&nbsp;</a></span>setLTRB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::setLTRB </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to (left, top, right, bottom). left and right are not sorted; left is not necessarily less than right. top and bottom are not sorted; top is not necessarily less than bottom.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">top</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">right</td><td>stored in fRight </td></tr>
    <tr><td class="paramname">bottom</td><td>stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a00e95e1c00e82ac601a21ac6694463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a00e95e1c00e82ac601a21ac6694463">&#9670;&nbsp;</a></span>setWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::setWH </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to (0, 0, width, height). Does not validate input; width or height may be negative.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>stored in fRight </td></tr>
    <tr><td class="paramname">height</td><td>stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6aece72c48ea4638f1a21f0a9aa4fed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aece72c48ea4638f1a21f0a9aa4fed6">&#9670;&nbsp;</a></span>setXYWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::setXYWH </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> to (x, y, x + width, y + height). Does not validate input; width or height may be negative.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">y</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">width</td><td>added to x and stored in fRight </td></tr>
    <tr><td class="paramname">height</td><td>added to y and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f11ca8d611000b282c38daa3dc4cab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f11ca8d611000b282c38daa3dc4cab9">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MNN::CV::Rect::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps fLeft and fRight if fLeft is greater than fRight; and swaps fTop and fBottom if fTop is greater than fBottom. Result may be empty; and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a95c8b45618876fd833da41c5b3be6954">width()</a> and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#aa7fc5d37b129f7f1f29a1e42f6539ad3">height()</a> will be zero or positive. </p>

</div>
</div>
<a id="a01177c3c1c082e37bc19527e7c2b663f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01177c3c1c082e37bc19527e7c2b663f">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns top edge of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, if sorted. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ad29c16121be6701ae8bddfc19b8e0af8">isEmpty()</a> to see if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> may be invalid, and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>返回</dt><dd>fTop </dd></dl>

</div>
</div>
<a id="a95c8b45618876fd833da41c5b3be6954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c8b45618876fd833da41c5b3be6954">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the x-axis. This does not check if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is sorted, or if result fits in 32-bit float; result may be negative or infinity.</p>
<dl class="section return"><dt>返回</dt><dd>fRight minus fLeft </dd></dl>

</div>
</div>
<a id="af58f6d07f1c5cb1622f3878ee9d3e8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58f6d07f1c5cb1622f3878ee9d3e8f2">&#9670;&nbsp;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns left edge of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, if sorted. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ac0571b2879b52e0c733428b47c3880e2">isSorted()</a> to see if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> is valid. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>返回</dt><dd>fLeft </dd></dl>

</div>
</div>
<a id="a1a01972b232acc3d8a90719e548d919e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a01972b232acc3d8a90719e548d919e">&#9670;&nbsp;</a></span>y()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::y </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns top edge of <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a>, if sorted. Call <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#ad29c16121be6701ae8bddfc19b8e0af8">isEmpty()</a> to see if <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html">Rect</a> may be invalid, and <a class="el" href="struct_m_n_n_1_1_c_v_1_1_rect.html#a0f11ca8d611000b282c38daa3dc4cab9">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>返回</dt><dd>fTop </dd></dl>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a405b1f172d1edcd94b5bd9958a1bf2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405b1f172d1edcd94b5bd9958a1bf2de">&#9670;&nbsp;</a></span>fBottom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::fBottom</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>larger y-axis bounds </p>

</div>
</div>
<a id="a64258783d446020019f2062282afdcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64258783d446020019f2062282afdcdd">&#9670;&nbsp;</a></span>fLeft</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::fLeft</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smaller x-axis bounds </p>

</div>
</div>
<a id="a0359c6cdfd938d0b8d0396315d996904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0359c6cdfd938d0b8d0396315d996904">&#9670;&nbsp;</a></span>fRight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::fRight</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>larger x-axis bounds </p>

</div>
</div>
<a id="a208f7896ff9557d5cef93add6696d15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208f7896ff9557d5cef93add6696d15f">&#9670;&nbsp;</a></span>fTop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MNN::CV::Rect::fTop</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>smaller y-axis bounds </p>

</div>
</div>
<hr/>该结构体的文档由以下文件生成:<ul>
<li>include/<a class="el" href="_rect_8h_source.html">Rect.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
